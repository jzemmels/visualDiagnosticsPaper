%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics
\usepackage{amsmath,amssymb,array}

% \usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[margin=1in,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{subcaption} % Sub figures
\usepackage{graphicx} % better graphics
\usepackage{float}
\usepackage[dvipsnames]{xcolor} % colors

% \usepackage{enumitem} % Customized lists
% \setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{hyperref} % For hyperlinks in the PDF
\usepackage{nameref} % \Cref command automatically handles figure/table/etc refs

\usepackage{natbib}
\bibliographystyle{abbrvnat}

% Commands for editing
\newcommand{\hh}[1]{{\textcolor{orange}{#1}}}
\newcommand{\svp}[1]{{\textcolor{blue}{#1}}}
\newcommand{\jz}[1]{{\textcolor{ForestGreen}{#1}}}

\newcommand{\code}[1]{\texttt{{#1}}}
\newcommand{\pkg}[1]{\texttt{{#1}}}
\newcommand{\R}{\mathbb{R}}

\usepackage[]{algorithm2e}

\defcitealias{pcast}{PCAST,~2016}
\defcitealias{firearmsToolmarksOverview}{GBI,~2015}
%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{Visual Diagnostics: assessing similarity of breech face impressions} % Article title
\author{%
\textsc{Joseph Zemmels}$^1$\thanks{Corresponding author: \href{mailto:jzemmels@iastate.edu}{jzemmels@iastate.edu}\newline This work was partially funded by the Center for Statistics and Applications in Forensic Evidence (CSAFE) through Cooperative Agreement 70NANB20H019 between NIST and Iowa State University, which includes activities carried out at Carnegie Mellon University, Duke University, University of California Irvine, University of Virginia, West Virginia University, University of Pennsylvania, Swarthmore College and University of Nebraska, Lincoln.}\hspace{2em}
\textsc{Susan VanderPlas}$^2$\hspace{2em}
\textsc{Heike Hofmann}$^1$\\[1ex] % Your name
{\footnotesize
$^1$ Center for Statistics and Applications in Forensic Evidence, Iowa State University;
$^2$ University of Nebraska Lincoln;
} %
}
\date{\today} % Leave empty to omit a date

%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\maketitle
\begin{abstract}
\noindent
Come back to later
% Dummy abstract text - replace \blindtext with your abstract text
\end{abstract}

\tableofcontents
%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

<<setup, include=FALSE>>=
library(tidyverse)
library(knitr)
library(patchwork)

# install.packages("cmcR")
library(cmcR)
# remotes::install_github("jzemmels/impressions")
library(impressions)

library(x3ptools)
# install.packages("raster")
library(raster)

theme_set(theme_bw())

knitr::opts_chunk$set(
  fig.path="figures/", echo=FALSE,
  out.width = '\\linewidth',
  fig.align = "center",
  fig.pos = "htbp",
  strip.white = TRUE,
  warning=TRUE,
  cache = TRUE)

nonMatch_processed <- x3ptools::x3p_read("data/K002eG1_processed.x3p")
nonMatch_processed$surface.matrix <- nonMatch_processed$surface.matrix*1e6
reference_processed <- x3ptools::x3p_read("data/K013sA1_processed.x3p") %>%
  x3p_interpolate(resx = nonMatch_processed$header.info$incrementX,
                  resy = nonMatch_processed$header.info$incrementY)
reference_processed$surface.matrix <- reference_processed$surface.matrix*1e6
target_processed <- x3ptools::x3p_read("data/K013sA2_processed.x3p") %>%
  x3p_interpolate(resx = nonMatch_processed$header.info$incrementX,
                  resy = nonMatch_processed$header.info$incrementY)
target_processed$surface.matrix <- target_processed$surface.matrix*1e6
if(!file.exists("figures/K013sA2_original.png")){
  ggsave(impressions::x3pPlot(target_processed),filename = "figures/K013sA2_original.png")
}

# visualize two cartridge case surfaces using an rgl device
source("code/x3pSurfaceVisualization.R",local = TRUE)
@

<<comparisonResults_code,cache=TRUE,include=FALSE>>=
comparisonResults_cell <-
  map2_dfr(list(target_processed,nonMatch_processed),
           c("K013sA2","K002eG1"),
           function(scan,scanName){

             map_dfr(seq(-30,30,by = 3),
                     function(theta){

                       comparison_allTogether(reference = reference_processed,
                                              target = target_processed,
                                              theta = theta,numCells = c(8,8),
                                              maxMissingProp = .99,
                                              sideLengthMultiplier = 3,
                                              returnX3Ps = TRUE)

                     }) %>%
               dplyr::mutate(originalMethod = decision_CMC(cellIndex = cellIndex,x=x,y=y,theta=theta,corr=pairwiseCompCor),
                             comparisonName = paste0("K013sA1 vs. ",scanName))

           })  %>%
  dplyr::group_by(comparisonName,cellIndex) %>%
  dplyr::filter(pairwiseCompCor == max(pairwiseCompCor)) %>%
  dplyr::ungroup()

saveRDS(comparisonResults_cell,file = "data/comparisonResults_cell.rds")

comparisonResults_fullScan <- map_dfr(seq(-30,30,by = 3),
                                      function(theta){

                                        reference_processed %>%
                                          comparison_allTogether(target = target_processed,
                                                                 theta = theta,
                                                                 numCells = c(1,1),
                                                                 maxMissingProp = .99,
                                                                 sideLengthMultiplier = 1.1,
                                                                 returnX3Ps = TRUE)

                                      }) %>%
  filter(fft_ccf == max(fft_ccf)) %>%
  mutate(comparisonName = "K013sA1 vs. K013sA2")

saveRDS(comparisonResults_fullScan,file = "data/comparisonResults_fullScan.rds")
@

<<include=FALSE>>=
comparisonResults_cell <- readRDS("data/comparisonResults_cell.rds")
comparisonResults_fullScan <- readRDS("data/comparisonResults_fullScan.rds")
@


\section{Background and Introduction}

Forensic examinations are intended to provide an objective assessment of the probative value of a piece of evidence.
Typically, this assessment of probative value is performed by a forensic examiner who visually inspects the evidence to determine whether it matches evidence found on a suspect.
The process by which an examiner arrives at their evidentiary conclusion is largely opaque and has been criticized \citepalias{pcast} because its subjectivity does not allow for an estimation of error rates.
In response, \citet{nas} pushed to augment subjective decisions made by forensic examiners with automatic, statistically-founded algorithms that objectively assess evidence and can be explained during court testimony.
These algorithms enable the quantification of an examiner's uncertainty by measuring the probative value of a piece of evidence.

A \emph{cartridge case} (see \autoref{fig:cartridgeCaseBullet}) is the portion of firearm ammunition that encases a projectile (e.g., bullet, shots, or slug) along with the explosive used to propel the projectile through the firearm.
When a firearm is discharged, the projectile is propelled down the barrel of the firearm, while the cartridge case is forced towards the back of the barrel.
The base of the cartridge case (\autoref{fig:cartridgeCaseBase}) strikes the back wall, known as the \emph{breech face}, of the barrel with considerable force, thereby imprinting any markings on the breech face onto the cartridge case and creating the so-called \emph{breech face impressions} (see \autoref{fig:breechFaceImpressions}).
These markings have been suggested to be unique to a firearm and are used in forensic examinations to determine whether two cartridge cases have been fired by the same firearm.

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{images/cartridgeCaseZoomIn.png}
\subfloat[\label{fig:cartridgeCaseBullet} Fired cartridge case and bullet \citep{firearm_id_thompson}]{\hspace{.27\linewidth}}
\hspace{.06\linewidth}
\subfloat[\label{fig:cartridgeCaseBase} Base of the cartridge case that comes into contact with the breech face of the firearm \citep{firearmsToolmarksOverview}]{\hspace{.273\linewidth}}
\hspace{.07\linewidth}
\subfloat[\label{fig:breechFaceImpressions}  Zoom into the \emph{primer} region showing breech face impressions \citep{fadul}]{\hspace{.31\linewidth}}\newline
\caption{\label{fig:cartridgeCaseZoomIn} \hh{XXX some space to say something more}}
\end{figure}


We measure the surface of a cartridge case using a TopMatch-3D High-Capacity Scanner \citep{topmatch} by Cadre Forensics\texttrademark.
This scanner collects images under various lighting conditions of a gel pad into which the cartridge case surface is impressed and combines these images into a regular 2D array called a \emph{surface matrix}. Examples of two such surface matrices are shown in \autoref{fig:referenceAnnotated} and \autoref{fig:targetAnnotated}.
The physical dimensions of these objects are about 5.5 $mm^2$ captured at a resolution of 1.84 microns per pixel (1000 microns equals 1 mm).
Each element of the surface matrix corresponds to the height of the impressed gel at that location.
The nominal resolution for height measurements depends on the viscosity of the gel and is reported to be better than 1 micron.
The breech face impression regions have been manually annotated (in red).
Using this manual annotation, we isolate the breech face impression region.
Note that this introduces structurally missing values into the scan.

\autoref{fig:processedSideBySide} shows the isolated breech face impression regions where the height values of the surface have been mapped to a diverging purple (low) to orange (high) color scale and missing values are shown in gray.
\hh{Note that due to the scanning process the physical location of any measured values is relative, but the relationship of the measurements to each other is fixed. This means that we can, without affecting any structures, translate and even rotate measurements in 3d space. For the purpose of making scans comparable to each other, the scan surfaces are translated into XXXX what is being done exactly?} \jz{XXX I'm not sure what step in the algorithm you're referring to here. By "translated into," do you mean a horizontal/vertical shift? }\hh{Yes, I used translation in a mathematical sense here, so any shift in x, y or z direction. Sometimes we do these steps implicitly rather than in an explicit ... this is a step way. e.g. by changing from a grid to matrix we lose the physical extensions in x and y. Those are replaced by integer values first, and then rescaled into micron measurements later. That is an implicit translation in x and y. shifting a scan into a mean zero is an explicit translation, just as shifting a breech face impression is. I would very much like to use a robust estimate of the 2d breech face surface as the zero plane.} \hh{their mean and any tilts in xy direction are removed. While those tilts might stem from a small misalignments of the breech face, a bigger source of variability stems from a slight misalignment during the scanning. }


\begin{figure}[htbp]
\centering
\begin{subfigure}[c]{0.35\textwidth}
K013sA1 \hfill\newline
\includegraphics[width=\textwidth]{figures/topMatchAnnotatedreference.png}
\caption{Cartridge case scan K013sA1 with breech face (BF) impressions manually annotated in red.}
\label{fig:referenceAnnotated}
\end{subfigure}
\begin{subfigure}[c]{0.2\textwidth}
\includegraphics[width=\textwidth]{figures/referenceTargetSideBySide.png}
\caption{Processed surface matrices.}
\label{fig:processedSideBySide}
\end{subfigure}
\begin{subfigure}[c]{0.35\textwidth}
K013sA2 \hfill\newline
\includegraphics[width=\textwidth]{figures/topMatchAnnotatedTarget.png}
\caption{Cartridge case scan K013sA2 with breech face (BF) impressions manually annotated in red.}
\label{fig:targetAnnotated}
\end{subfigure}
\caption{Raw scans (left and right) and processed versions of the surface matrices (in the middle) for a pair of cartridge cases fired by the same handgun \cite[Ruger SR9, Gun A1, SerialNo 331-96383;][]{Baldwin}.}
\label{fig:annotatedBFImpressions}
\end{figure}



\hh{XXX Great! It feels like we have reached the end of the introduction. }
\hh{todo list: (1) problem statement, (2) outline what this paper is about and order in which we go about it. XXX We probably have to go back to this a couple times. }

\jz{Problem statement (draft): Can we characterize when a cartridge case alignment fails?}

\jz{Even among matching cartridge case pairs, we have found results like those shown in \autoref{fig:cmcPlot_match}, where only a small number of the total cells are classified as CMCs, to be quite common.
An underlying assumption of the CMC methodology is that many source cells should find the "correct" registration in a matching target scan.
However, it can be difficult to determine why a particular cell did or did not register correctly.
In this paper, we introduce diagnostic tools that can be used to visually and numerically characterize the quality of alignment of cells.
We also demonstrate how the numerical diagnostics can be used as features to classify matching and non-matching cartridge case pairs.}

\jz{Paper outline (draft):}

\begin{itemize}
\item \jz{Define cell-based registration procedure, use algorithm environment as in JDSSV paper}

\item \jz{Visual Diagnostics}

\begin{itemize}
\item \jz{Discuss comparison plot}

\item \jz{Define diagnostic statistics}

\item \jz{discuss connections between visual diagnostic and diagnostic statistics}
\end{itemize}

\item \jz{cartridgeInvestigatR application}

\item \jz{Conclusion}
\end{itemize}

\subsection{Notational Conventions}

As the name implies, surface matrices are two-dimensional arrays whose elements contain relative height values of the corresponding cartridge case surface \citep{x3p}.
For notational simplicity, we assume that the matrices are square, i.e. $A \in \R^{k \times k}$ for some matrix $A$ and $k > 0$.
Note, that any assumption of sizing of matrices are easily enforced by  padding with additional missing values. Due to the presence  of (structural) missing values around the breech face impression, additional padding does not interfere with the structure of the scan.
We use lowercase letters with subscripts to denote a particular value of a matrix; e.g., $a_{ij}$ is the value in the $i$th row and $j$th column, starting from the top left corner, of $A$.

For the purpose of dealing with missing values mathematically, we adapt standard matrix algebra as follows: if an element of either matrix $A$ or $B$ is missing, then any element-wise operation including this element is also missing, otherwise standard matrix algebra holds.
For example, for matrices $A$ and $B \in \R^{k \times k}$ we define the addition operator as:
\[
A \oplus_{\tiny{NA}} B = \left( a_{ij} \oplus_{\tiny{NA}} b_{ij} \right)_{1 \le i,j \le k} :=
\begin{cases}
a_{ij} + b_{ij} & \text{ if both } a_{ij} \text{ and } b_{ij} \text{ are numbers}\\
\text{NA } & \text{ otherwise}
\end{cases}
\]
Operations $\ominus_{\tiny{NA}}$ as well as all comparisons are defined similarly. For the purpose of readability, we will use the standard algebraic operators $+, -, >, <, ...$ and apply the extended operations as defined above.

\subsection{Registration Procedure}

\jz{[Include visual illustrating the full scan and cell-based registrations]}

A critical step in comparing $A$ and $B$ is to find a transformation of $B$ such that it aligns best to $A$ (or vice versa).
In image processing, this is called \textit{image registration}. Noting that $A$ and $B$ are essentially grayscale images, we rely on a standard image registration technique \citep{Brown1992}.

In our application, a registration is composed of a discrete translation by $(m,n) \in \mathbb{Z}^2$ and rotation by $\theta \in [-180^\circ,180^\circ]$.
To determine the optimal registration, we calculate the \textit{cross-correlation function} (CCF) between $A$ and $B$, which measures the similarity between $A$ and $B$ for every possible translation of $B$, denoted $(A \star B)$.
We estimate the registration by calculating the maximum CCF value across a range of rotations of matrix $B$.
Let $B_\theta$ denote $B$ rotated by an angle $\theta \in [-180^\circ,180^\circ]$ and $b_{\theta_{mn}}$ the $m,n$-th element of $B_\theta$.
Then the estimated registration $(m^*,n^*,\theta^*)$ is:

\begin{align*}
(m^*,n^*,\theta^*) = \arg \max_{m,n,\theta} (a \star b_\theta)_{mn}.
\end{align*}

In practice we consider a discrete grid of rotations $\pmb{\Theta} \subset [-180^\circ,180^\circ]$.
The registration procedure is outlined in \autoref{alg:registration}.
We refer to the matrix that is rotated as the "target."
The result is the estimated registration of the target matrix to the "reference" matrix.

\begin{algorithm}[htbp]
\KwData{Reference matrix $A$, target matrix $B$, and rotation grid $\pmb{\Theta}$}
\KwResult{Estimated registration of $B$ to $A$, $(m^*,n^*,\theta^*)$, and cross-correlation function maximum, $CCF_{\max}$}
\For{$\theta \in \pmb{\Theta}$}{
Rotate $B$ by $\theta$ to obtain $B_\theta$\;
Calculate $CCF_{\max, \theta} = \max_{m,n} (a \star b_{\theta})_{mn}$\;
Calculate translation $[m^*_\theta,n^*_\theta] = \arg \max_{m,n} (a \star b_{\theta})_{mn}$
}
Calculate overall maximum correlation $CCF_{\max} = \max_{\theta} \{CCF_{\max,\theta} : \theta \in \pmb{\Theta}\}$\;
Calculate rotation $\theta^* = \arg \max_{\theta} \{CCF_{\max,\theta} : \theta \in \pmb{\Theta}\}$\;
\Return{Estimated rotation $\theta^*$, translation $m^* = m^*_{\theta^*}$ and $n^* = n^*_{\theta^*}$, and $CCF_{\max}$}
\caption{Image Registration Procedure}
\label{alg:registration}
\end{algorithm}

\citet{song_proposed_2013} points out that two matching cartridge cases may only have a handful of regions with distinguishable, matching impressions due to inherent variability in the firing process.
Calculating a correlation between two full scans as in \autoref{alg:registration} may not highlight their similarities.
Instead, \citet{song_proposed_2013} proposes partitioning one of the scans into a grid of "cells" and estimating the registration between each cell and the other scan.

We now extend the surface matrix notation introduced previously to accommodate cells.
Let $A_{t}$ denote the $t$th cell of matrix $A$, $t = 1,...,T_A$ where $T_A$ is the total number of cells containing non-missing values (e.g., $T_A = 43$ in \autoref{fig:cellGridExample}) in scan $A$ and let $(a_t)_{ij}$ denote the $i,j$-th element of $A_t$.
This procedure can be viewed as a generalization of \autoref{alg:registration} that we call the "cell-based comparison procedure" and outline in \autoref{alg:cellComparison}.

\begin{algorithm}[H]
\KwData{Reference matrix $A$, target matrix $B^*$, cell grid size $R \times C$, and rotation grid $\pmb{\Theta}'_A$}
\KwResult{Estimated translations and $CCF_{\max}$ values per cell, per rotation}
Partition $A$ into a grid of $R \times C$ cells\;
Discard cells containing only missing values, leaving $T_A$ remaining cells\;
\For{$\theta \in \pmb{\Theta}'_A$}{
Rotate $B^*$ by $\theta$ to obtain $B^*_\theta$\;
\For{$t = 1,...,T_A$}{
Calculate $CCF_{\max, A,t,\theta} = \max_{m,n} (a_t \star b^*_\theta)_{mn}$\;
Calculate translation $[m^*_{A,t,\theta},n^*_{A,t,\theta}] = \arg \max_{m,n} (a_t \star b^*_\theta)_{mn}$
}
}
\Return{$\pmb{F}_A = \{(m^*_{A,t,\theta},n^*_{A,t,\theta}, CCF_{\max,A,t,\theta}, \theta) : \theta \in \pmb{\Theta}'_A, t = 1,...,T_A\}$}
\caption{Cell-Based Comparison Procedure}
\label{alg:cellComparison}
\end{algorithm}

\jz{[Describe what we expect to see in $\pmb{F}_A$. E.g., agreement in registrations for matching scans.]}

\section{Visual Diagnostics}

\subsection{The X3P Plot}

The first visual diagnostic tool we discuss is the "X3P plot" which is used to visualize the values of a scan's surface matrix.
We show an example of an X3P plot in \autoref{fig:preProcessEffectExample}, which will be discussed in more detail below.
The orientation of the X3P plot is the same as its underlying surface matrix, meaning the top left-most pixel represents the $[1,1]$-th element of the surface matrix followed the $[1,2]$-th element to its immediate right and so on.
To construct the X3P plot, we map 11 percentiles of the non-missing values in a surface matrix to the continuous, divergent purple-white-orange color scheme illustrated in \autoref{fig:x3pPlot_colorscheme}.
The darkest shades of purple and orange represent the minimum and maximum surface values, respectively.
We use a very light shade of gray to represent the median surface value to ensure symmetry in the percentile mapping.
Rather than mapping deciles to the 11 colors (minimum, 10th percentile, 20th percentile, etc.), we've found the more polarized mapping shown in \autoref{fig:x3pPlot_colorscheme} to be more effective at emphasizing extreme surface values, which are commonly associated with the most prominent impressions.


\begin{figure}[htbp]
\centering
\includegraphics[clip,width=\textwidth]{images/x3pPlot_colorscheme.png}
\caption{The percentiles (top) and hexidecimal color values (bottom) used in the color mapping of the X3P plot.}
\label{fig:x3pPlot_colorscheme}
\end{figure}

To visualize two or more scans using the X3P plot, we map percentiles of the pooled surface values to the same color scale.
This allows us to compare the relative sizes of impressions across multiple cartridge cases.
The registration procedure outlined in \autoref{alg:registration} is highly sensitive to extreme values on either surface, so performing a visual comparison of two scans using the X3P plot is useful for identifying whether further processing of either scan is needed.

\autoref{fig:preProcessEffectExample} shows two examples of the registration output for a matching pair of scans labeled K002eG2 and K227iG3.
In the top plot we see that both scans contain large, extraneous markings that may affect the registration procedure.
There is a ring of raised observations around the center of K002eG2 that is an artifact of the deformation that occurs when the firing pin strikes the cartridge case primer.
Additionally, there are large dent-like markings on both K002eG2 and K227iG3.
Registering these two scans using \autoref{alg:registration} results in $CCF_{\max} = 0.14$ at registration $(m^*,n^*,\theta^*) = (4,19,-6^\circ)$.

The bottom plot of \autoref{fig:preProcessEffectExample} shows the registrations of K002eG2 and K227iG3 after applying the additional pre-processing of removing the extraneous regions.
The output of \autoref{alg:registration} is now $CCF_{\max} = 0.29$ at registration $(m^*,n^*,\theta^*) = (6,18,-6^\circ)$.
Although the registrations are similar for both pairs of scans, the cross-correlation value more than doubles when we remove the extraneous regions.
We also note that removal of the extreme values makes it easier to visually identify similar markings between K002eG2 and K227iG3, such as the "striped" impressions at the top of the two scans.
Highlighting such similarities is one of the strengths of the X3P plot.

<<preProcessEffectExample_code, include=FALSE,cache=TRUE>>=

# compare original scans
barrelB_scan1_original <- x3ptools::x3p_read("data/K002eG2_original.x3p")
barrelB_scan2_original <- x3ptools::x3p_read("data/K227iG3_original.x3p")
barrelB_scan2_original <- x3ptools::x3p_interpolate(barrelB_scan2_original,resx = barrelB_scan1_original$header.info$incrementY)

barrelB_originalComparison <- scored::comparison_fullScan(barrelB_scan1_original,
                                                          barrelB_scan2_original) %>%
  filter(direction == "reference_vs_target") %>%
  filter(fft_ccf == max(fft_ccf))

scan1_original_aligned <- barrelB_originalComparison$cellHeightValues[[1]]
scan1_original_aligned$surface.matrix <-
  barrelB_originalComparison$cellHeightValues[[1]]$surface.matrix*barrelB_originalComparison$cellHeightValues[[1]]$cmcR.info$scaleByVal + barrelB_originalComparison$cellHeightValues[[1]]$cmcR.info$centerByVal

scan2_original_aligned <- barrelB_originalComparison$alignedTargetCell[[1]]
scan2_original_aligned$surface.matrix <-
  barrelB_originalComparison$alignedTargetCell[[1]]$surface.matrix*barrelB_originalComparison$alignedTargetCell[[1]]$cmcR.info$scaleByVal + barrelB_originalComparison$alignedTargetCell[[1]]$cmcR.info$centerByVal

# compare scans with extra pre-processing
barrelB_scan1_preProc <- x3ptools::x3p_read("data/K002eG2_processed.x3p")
barrelB_scan2_preProc <- x3ptools::x3p_read("data/K227iG3_processed.x3p")
barrelB_scan2_preProc <- x3ptools::x3p_interpolate(barrelB_scan2_preProc,resx = barrelB_scan1_preProc$header.info$incrementY)

barrelB_preProcComparison <- scored::comparison_fullScan(barrelB_scan1_preProc,
                                                         barrelB_scan2_preProc) %>%
  filter(direction == "reference_vs_target") %>%
  filter(fft_ccf == max(fft_ccf))

scan1_preProc_aligned <- barrelB_preProcComparison$cellHeightValues[[1]]
scan1_preProc_aligned$surface.matrix <-
  barrelB_preProcComparison$cellHeightValues[[1]]$surface.matrix*barrelB_preProcComparison$cellHeightValues[[1]]$cmcR.info$scaleByVal + barrelB_preProcComparison$cellHeightValues[[1]]$cmcR.info$centerByVal

scan2_preProc_aligned <- barrelB_preProcComparison$alignedTargetCell[[1]]
scan2_preProc_aligned$surface.matrix <-
  barrelB_preProcComparison$alignedTargetCell[[1]]$surface.matrix*barrelB_preProcComparison$alignedTargetCell[[1]]$cmcR.info$scaleByVal + barrelB_preProcComparison$alignedTargetCell[[1]]$cmcR.info$centerByVal

plt1 <- impressions::x3pPlot(scan1_original_aligned,scan2_original_aligned,
                x3pNames = c("K002eG2 Original","K227iG3 Original"),
                legend.quantiles = c(0,.01,.5,.99,1),
                legendLength = 10) +
  labs(caption = paste0("CCF: ",round(barrelB_originalComparison$fft_ccf,2))) +
  theme(plot.caption = element_text(hjust = .5))

plt2 <- impressions::x3pPlot(scan1_preProc_aligned,scan2_preProc_aligned,
                x3pNames = c("K002eG2 + Additional Pre-processing","K227iG3 + Additional Pre-processing"),
                legend.quantiles = c(0,.01,.5,.99,1),
                legendLength = 10) +
  labs(caption = paste0("CCF: ",round(barrelB_preProcComparison$fft_ccf,2))) +
  theme(plot.caption = element_text(hjust = .5))

ggsave(plot = {patchwork::wrap_plots(plt1,plt2,ncol = 1)},filename = "figures/preProcessEffectExample.png")
@


\begin{figure}[!htbp]
\centering
\includegraphics[width=\textwidth]{figures/preProcessEffectExample.png}
\caption{Registration results from comparing two versions of a matching pair of cartridge case scans. In the first comparison (top), extraneous values are left in the scan which causes the overall $CCF_{\max}$ value to be relatively low (0.14). When these values are removed (bottom), the CCF value more than doubles to 0.29. The X3P plot is useful for identifying scans that are in need of additional pre-processing.}
\label{fig:preProcessEffectExample}
\end{figure}

\subsection{The Comparison Plot}

The "comparison plot" is a visual diagnostic tool that uses the X3P plot to directly compare the surface values of two scans.
The comparison plot provides a quick, intuitive assessment by partitioning the surfaces into similarities and differences.
To construct the comparison plot we first obtain two aligned scans $A$ and $B*$ using \autoref{alg:registration}.
A comparison plot like the one shown in \autoref{fig:complementCompPlot_fullScan} depicts aligned versions of the two scans $A$ = K013sA1 and $B$ = K013sA2 shown in \autoref{fig:processedSideBySide}.
The dark gray (gray40) elements in these two visualizations represent the non-overlapping elements from the other scan.
Next, we wish to partition these $A$ and $B^*$ into similarities and differences using a filter operation.

For a matrix $X \in \mathbb{R}^{k \times k}$ and Boolean-valued condition matrix $cond: \mathbb{R}^{k \times k} \to \{TRUE,FALSE\}^{k \times k}$, we define an element-wise filter operation $\mathcal{F}: \mathbb{R}^{k \times k} \to \mathbb{R}^{k \times k}$ as:

\begin{align*}
\mathcal{F}_{cond}(X) =
(f_{ij})_{1 \leq i,j \leq k} =
\begin{cases}
x_{ij} &\text{if $cond$ is $TRUE$ for element $i,j$} \\
NA &\text{otherwise.}
\end{cases}
\end{align*}

The resulting $\mathcal{F}_{cond}(X)$ is a copy of the matrix $X$ where elements for which $cond$ is $TRUE$ are replaced with $NA$.
The filtering operation allows us to isolate elements of a surface matrix that satisfy some criterion.
For example, we can isolate a surface matrix to only those elements that are close to the elements of another surface matrix.

We compute the element-wise average $\frac{1}{2}(A + B^*)$ and absolute difference $|A - B^*|$ as shown in the left and middle of \autoref{fig:averageFilterExample}.
We also construct Boolean-valued matrices $|A - B^*| \leq \tau$ and $|A - B^*| > \tau$ based on whether the element-wise absolute difference is at most or greater than a threshold $\tau > 0$.
For example, the right side of \autoref{fig:averageFilterExample} shows the elements of matrix $|A - B^*| > 1.5$ with $TRUE$ elements represented as white pixels and $FALSE$ elements as black pixels.
% We note that there are many more $FALSE$ elements, where the surfaces of $A$ and $B^*$ are "close," than $TRUE$ elements.


<<include=FALSE>>=
reference <- comparisonResults_fullScan %>%
  pull(cellHeightValues) %>%
  .[[1]]

reference$surface.matrix <- reference$surface.matrix*reference$cmcR.info$scaleByVal

target <- comparisonResults_fullScan %>%
  pull(alignedTargetCell) %>%
  .[[1]]

target$surface.matrix <- target$surface.matrix*target$cmcR.info$scaleByVal
@

<<comparisonPlot_filterIllustration_code,include=FALSE,cache=TRUE>>=
impressions::x3pPlot(reference,target,x3pNames = c("K013sA1","K013sA2"),type = "list") %>%
  walk2(c("K013sA1","K013sA2"),~  {
    ggsave(filename = paste0("figures/",.y,"_fullScan.png"),plot = .x,bg="white")
  })

elementwiseAverage_plt <- impressions::x3pPlot(impressions::x3p_elemAverage(reference,target),
                                               x3pNames = "Element-wise Average",
                                               legendLength = 7,
                                               legend.quantiles = c(0,.01,.5,.99,1)) +
  ggplot2::guides(fill = ggplot2::guide_colourbar(barheight = 7,
                                                  label.theme = ggplot2::element_text(size = 5),
                                                  title.theme = ggplot2::element_text(size = 7),
                                                  frame.colour = "black",
                                                  ticks.colour = "black"))

ggsave(plot = elementwiseAverage_plt,
       filename = "figures/elementwiseAverage_fullScan.png",bg="white")

surfaceDistance <- reference

surfaceDistance$surface.matrix <- abs(reference$surface.matrix - target$surface.matrix)

surfaceDistance_df <- surfaceDistance %>%
  impressions::x3p_to_dataFrame()

surfaceDistance_plt <- surfaceDistance_df %>%
  mutate(x3p = "Element-wise Absolute Difference") %>%
  ggplot2::ggplot(ggplot2::aes(x = x,y = y)) +
  ggplot2::geom_raster(ggplot2::aes(fill = value))  +
  ggplot2::scale_fill_gradientn(colours = c('#2d004b','#542788','#8073ac','#b2abd2','#d8daeb','#f7f7f7',
                                                     '#fee0b6','#fdb863','#e08214','#b35806','#7f3b08'),
                                                     values = scales::rescale(quantile(surfaceDistance_df$value,
                                                                                       c(0,.01,.025,.1,.25,.5,.75,0.9,.975,.99,1),
                                                                                       na.rm = TRUE)),
                                breaks = function(lims){
                                  dat <- quantile(surfaceDistance_df$value,c(0,.8736,.99,1),na.rm = TRUE)

                                  dat <- dat %>%
                                    setNames(paste0(names(dat)," [",round(dat,3),"]"))

                                  return(dat)
                                },
                                limits = c(0,NA),
                                na.value = "grey65") +
  ggplot2::coord_fixed(expand = FALSE) +
  ggplot2::theme_minimal() +
  ggplot2::theme(
    axis.title.x = ggplot2::element_blank(),
    axis.text.x = ggplot2::element_blank(),
    axis.ticks.x = ggplot2::element_blank(),
    axis.title.y = ggplot2::element_blank(),
    axis.text.y = ggplot2::element_blank(),
    axis.ticks.y = ggplot2::element_blank(),
    panel.grid.major = ggplot2::element_blank(),
    panel.grid.minor = ggplot2::element_blank(),
    panel.background = ggplot2::element_blank()) +
  ggplot2::guides(fill = ggplot2::guide_colourbar(barheight = 7,
                                                  label.theme = ggplot2::element_text(size = 5),
                                                  title.theme = ggplot2::element_text(size = 7),
                                                  frame.colour = "black",
                                                  ticks.colour = "black"),
                  colour = 'none') +
  ggplot2::labs(fill = expression("Rel. Height ["*mu*"m]")) +
  ggplot2::facet_wrap(~ x3p)


ggsave(surfaceDistance_plt,filename = "figures/surfaceDistance.png",bg="white")

surfaceDistance_bin <- surfaceDistance

surfaceDistance_bin$surface.matrix <- {surfaceDistance_bin$surface.matrix > 1.5}

surfaceDistance_bin_plt <- surfaceDistance_bin %>%
  impressions::x3p_to_dataFrame() %>%
  ggplot(aes(x=x,y=y,fill=value)) +
  geom_raster() +
  coord_fixed(expand=FALSE) +
  theme_void() +
  theme(legend.position = "none") +
  scale_fill_manual(values = c("black","white"),na.value = "gray65")

ggsave(surfaceDistance_bin_plt,filename = "figures/surfaceDistance_bin.png")

library(patchwork)

plt <- ((elementwiseAverage_plt +
           labs(title = "Element-wise\nAverage") +
           theme(strip.text = element_blank(),
                 plot.title = element_text(hjust = .55,vjust = -45,size = 8))) +
          (surfaceDistance_plt +
             labs(title = "Element-wise\nAbsolute\nDifference") +
             theme(strip.text = element_blank(),
                   plot.title = element_text(hjust=.55,vjust=-45,size = 8))) +
          (surfaceDistance_bin_plt +
             labs(title = "Abs. Difference > 1.5") +
             theme(strip.text = element_blank(),
                   plot.title = element_text(hjust=.65,vjust=-40,size = 8)))) +
  patchwork::plot_annotation(title = "K013sA1 vs. Aligned K013sA2",
                             theme = theme(plot.title = element_text(size = 10,hjust = .5,vjust = -15)))

ggsave(plt,filename = "figures/averageFilterExample.png",bg = "white")
knitr::plot_crop("figures/averageFilterExample.png")

patchComparisonPlts_list <-
  impressions::x3p_comparisonPlot(x3p1 = reference,x3p2 = target,
                                  plotLabels = c(" ","  ","   ","    ","     "),
                                  legendLength = grid::unit(4,"in"),
                                  type = "list")

ggsave(patchComparisonPlts_list$`   `,filename = "figures/elementwiseAverage_filtered.png")
@

\begin{figure}[!htbp]
\centering
\includegraphics[width=\textwidth]{figures/averageFilterExample.png}
\caption{To construct the comparison plot after aligning the scans K013sA1 and K013sA2 shown in \autoref{fig:processedSideBySide}, we compute their element-wise average (left) and element-wise absolute difference (middle). We then compute a Boolean-valued matrix based on whether the elements of the element-wise absolute difference is greater or less than 1.5 microns (right). We use this Boolean matrix to distinguish between similarities and differences in the scan impressions.}
\label{fig:averageFilterExample}
\end{figure}


The middle column of the comparison plot shows the filtered element-wise matrix $\mathcal{F}_{|A - B^*| \leq \tau}\left(\frac{1}{2}(A + B^*)\right)$.
By isolating the element-wise average to "close" surface values between $A$ and $B^*$, the filtered element-wise average emphasizes similar markings between the two scans.
In \autoref{fig:complementCompPlot_fullScan}, we use a filtering threshold of $\tau = 1.5$ microns and represent filtered elements in light gray (gray80).
This filtered element-wise average illustrates that there are many similarities between the two surfaces.
To identify similarities using the element-wise average, we have found it most effective to scan the filtered element-wise average plot for distinctive markings, such as the deep purple and orange markings in the 5 o'clock position of the firing pin hole in \autoref{fig:complementCompPlot_fullScan}.
After identifying distinctive markings, it is relatively easy to identify the contributing markings from $A$ and $B^*$ by considering the same region in the two plots in the left column.
For example, we see deep purple and orange striped impressions in the 5 o'clock positions of $A$ and $B^*$ in \autoref{fig:complementCompPlot_fullScan}.
Cross-referencing the filtered element-wise average with the individual scans allows us to assess the degree of similarity and spatial relationship between markings on the two scans.

Complementary to the filtered element-wise average, the right column of the comparison plot shows differences between the two scans.
While it is visually obvious when scans share similar markings, characterizing different markings can be challenging.
For example, two markings may be different in their depth, shape, orientation, or spatial relationship to other markings.
As such, we visualize two filtered versions of the aligned scans $\mathcal{F}_{|A - B^*| > \tau}(A)$ and $\mathcal{F}_{|A - B^*| > \tau}(B^*)$ to emphasize differences.
The right column of \autoref{fig:complementCompPlot_fullScan} shows the filtered differences between scans $A$ and $B^*$ using a cutoff threshold of $\tau = 1.5$ microns.
Again, we've found it useful to study the two filtered plots to identify differences that can be cross-referenced against the original scans.
For example, scan $B^*$ has a dent-like marking at the 11 o'clock position of the firing pin hole that is not present in $A$.
On the other hand, we note a dark orange region in the 5 o'clock position, where we had previously noted similarities, that is treated as a difference.
Considering the original scans in the left column, we see that these orange regions are indeed part of the striped purple and orange impression region.
It can be safely assumed that these two regions should be treated as "similar" markings despite being at least 1.5 microns apart.
These two examples illustrate the fundamental challenge with characterizing differences - there are many ways in which two markings can be "different" from each other.

<<fullScanComparisonPlot,include = FALSE,cache=TRUE>>=

# debugonce(impressions::x3p_comparisonPlot)
patchComparisonPlts_combined <-
  impressions::x3p_comparisonPlot(x3p1 = reference,x3p2 = target,
                                  threshold = 1.5,
                                  plotLabels = c("K013sA1","K013sA2\nAligned",
                                                 "Filtered Element-wise Average",
                                                 "K013sA1\nDifferences",
                                                 "K013sA2\nAligned Differences"),
                                  labelSize = 2.5,
                                  legendLength = grid::unit(6,"in"),
                                  legendUnit = "micron",
                                  legendQuantiles = c(0,.01,.5,.99,1))

ggsave(plot = patchComparisonPlts_combined,filename = "figures/complementCompPlot_fullScan.png",
       width = 7,height = 7,bg = "white")
knitr::plot_crop("figures/complementCompPlot_fullScan.png")
@

\begin{figure}[!htbp]
\centering
\includegraphics[width=\textwidth]{figures/complementCompPlot_fullScan.png}
\caption{The comparison plot provides an intuitive visualization of the similarities and differences between two aligned surface matrices. The left column of the comparison plot shows two aligned scans. The middle column shows the element-wise average between the two aligned scans after filtering out surface values that are at least 1.5 microns apart. The right column shows these filtered surface values of the aligned scans. Together, the middle and right column show the "similarities" and "differences" between the two aligned scans.}
\label{fig:complementCompPlot_fullScan}
\end{figure}

<<matchCCP_combine, eval=TRUE,cache=FALSE,include=FALSE>>=
refCell <- comparisonResults_cell %>%
  filter(cellIndex == "3, 8") %>%
  slice(1) %>%
  pull(cellHeightValues) %>%
  .[[1]]

targCell <- comparisonResults_cell %>%
  filter(cellIndex == "3, 8") %>%
  slice(1) %>%
  pull(alignedTargetCell) %>%
  .[[1]]

patchComparisonPlts_combined <- impressions::x3p_comparisonPlot(
  x3p1 = refCell,x3p2 = targCell,labelSize = 3,
  plotLabels = c("K013sA1 Cell 3, 8",
                 "K013sA2 Aligned Cell",
                 "Element-wise Average",
                 "K013sA1 Cell 3, 8\nDifferences",
                 "K013sA2 Aligned Cell\nDifferences"))

ggsave(plot = patchComparisonPlts_combined,filename = "figures/complementCompPlot.png",
       width = 7,height = 7,bg = "white")
knitr::plot_crop("figures/complementCompPlot.png")
@

<<matchCCP_show, out.width=".9\\textwidth",fig.cap="\\label{fig:fivePlotComparison} The complementary comparison plot for two cells from the comparison between cell 3, 8 of scan K013sA1 and its aligned mate in scan K013sA2. The left column shows the surface values of these two cells. Note that non-overlapping pixels are shown in dark gray in the bottom left plot. The middle column shows similarities between the surfaces in the form of the filtered element-wise average. The right column shows the surface values with the opposite filtering used in the filtered element-wise average plot. A gray border is used to emphasize the filtered vs. non-filtered regions.", cache=FALSE>>=
knitr::include_graphics("figures/complementCompPlot.png")
@


\subsection{Visual Diagnostic Statistics}

Consider \autoref{fig:filterLabeling} that shows the filtered element-wise average $\mathcal{F}_{|A - B^*| < \tau}\left(\frac{1}{2}(A + B^*)\right)$ on the left and the associated $cond$ matrix $|A - B^*| < \tau$ visualized in black-and-white in the middle where filtered elements are shown in white.
We use a connected components labeling algorithm detailed in \citet{haralick_shapiro} to identify individual neighborhoods of filtered elements.
More precisely, the algorithm returns a set of sets $\pmb{S}_d = \{S_{d,1},S_{d,2},...,S_{d,L_d}\}$ where each $S_{d,l}$ is a set of indices of the $cond$ matrix that have a value of $TRUE$ and are connected by a chained-together sequence of 4 (Rook's) neighborhoods.
The right side of \autoref{fig:filterLabeling} shows each $S_{d,l}$ distinguished by different fill colors, $l = 1,...,L_d$.

<<include=FALSE>>=
compPlt <- patchComparisonPlts_combined

plt1 <- compPlt$patches$plots[[3]]

plt1$layers[[3]] <- NULL

scanFilterBinarized <- reference %>%
  impressions::x3p_elemAverage(target) %>%
  impressions::x3p_to_dataFrame() %>%
  mutate(value = (abs(c({reference$surface.matrix - target$surface.matrix})) > x3p_sd(reference,target)))

plt2 <- scanFilterBinarized %>%
  ggplot(aes(x=x,y=y,fill=value)) +
  geom_raster() +
  scale_fill_manual(values = c("black","white"),na.value = "gray65") +
  coord_fixed(expand = FALSE) +
  theme_void() +
  theme(legend.position = "none")


scanFilterLabeled <- scanFilterBinarized %>%
  mutate(x = x + 1,y = y + 1,
         value = ifelse(!value | is.na(value),0,1)) %>%
  imager::as.cimg() %>%
  imager::label() %>%
  as.data.frame() %>%
  mutate(value = factor(value))

plt3 <- scanFilterLabeled %>%
  ggplot(aes(x=x,y=y,fill=value)) +
  geom_raster() +
  coord_fixed(expand = FALSE) +
  theme_void() +
  theme(legend.position = "none") +
  scale_fill_manual(values = c("gray65",sample(RColorBrewer::brewer.pal(12,"Paired"),size = length(unique(scanFilterLabeled$value)) - 1,replace = TRUE)))

labeledBlobPlts_combined <- (plt1 + plt2 + plt3) & theme(panel.border = element_rect(colour = "black",fill = NA))

ggsave(plot = labeledBlobPlts_combined,filename = "figures/binarizedBlobs.png",bg = "white")
knitr::plot_crop("figures/binarizedBlobs.png")
@

<<>>=
knitr::include_graphics("figures/binarizedBlobs.png")
@

\subsection{The cartridgeInvestigatR Application}


\section{Discussion}

%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------

\bigskip
\begin{center}
{\large\bf SUPPLEMENTARY MATERIAL}
\end{center}

\begin{description}

\item[Title:] Brief description. (file type)

\item[R-package for MYNEW routine:] R-package MYNEW containing code to perform the diagnostic methods described in the article. The package also contains all datasets used as examples in the article. (GNU zipped tar file)

\item[TopMatch Example Scans:] Data set used in the illustration of MYNEW method in \autoref{diagnostics} (.txt file)

\end{description}

%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------


\bibliography{refs.bib}

%----------------------------------------------------------------------------------------
\newpage
\section*{Appendix}
\begin{appendix}
\section{Examples of CCPs}\label{additional.fives}
\hh{Include one (or more) example(s) of a five-plot ensemble for a non-match so that we can see the qualitative difference. }



\end{appendix}

\end{document}

