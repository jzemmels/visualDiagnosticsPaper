%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics
\usepackage{amsmath,amssymb,array}

% \usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[margin=1in,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{subcaption} % Sub figures
\usepackage{graphicx} % better graphics
\usepackage{float}
\usepackage[dvipsnames]{xcolor} % colors

% \usepackage{enumitem} % Customized lists
% \setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{hyperref} % For hyperlinks in the PDF
\usepackage{nameref} % \Cref command automatically handles figure/table/etc refs

\usepackage{natbib}
\bibliographystyle{abbrvnat}

% Commands for editing
\newcommand{\hh}[1]{{\textcolor{orange}{#1}}}
\newcommand{\svp}[1]{{\textcolor{blue}{#1}}}
\newcommand{\jz}[1]{{\textcolor{ForestGreen}{#1}}}

\newcommand{\code}[1]{\texttt{{#1}}}
\newcommand{\pkg}[1]{\texttt{{#1}}}
\newcommand{\R}{\mathbb{R}}

\usepackage[]{algorithm2e}

\defcitealias{pcast}{PCAST,~2016}
\defcitealias{firearmsToolmarksOverview}{GBI,~2015}
%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{Visual Diagnostics: assessing similarity of breech face impressions} % Article title
\author{%
\textsc{Joseph Zemmels}$^1$\thanks{Corresponding author: \href{mailto:jzemmels@iastate.edu}{jzemmels@iastate.edu}\newline This work was partially funded by the Center for Statistics and Applications in Forensic Evidence (CSAFE) through Cooperative Agreement 70NANB20H019 between NIST and Iowa State University, which includes activities carried out at Carnegie Mellon University, Duke University, University of California Irvine, University of Virginia, West Virginia University, University of Pennsylvania, Swarthmore College and University of Nebraska, Lincoln.}\hspace{2em}
\textsc{Susan VanderPlas}$^2$\hspace{2em}
\textsc{Heike Hofmann}$^1$\\[1ex] % Your name
{\footnotesize
$^1$ Center for Statistics and Applications in Forensic Evidence, Iowa State University;
$^2$ University of Nebraska Lincoln;
} %
}
\date{\today} % Leave empty to omit a date

%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\maketitle
\begin{abstract}
\noindent
Come back to later
% Dummy abstract text - replace \blindtext with your abstract text
\end{abstract}

\tableofcontents
%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

<<setup, echo=FALSE, warning=FALSE, message=FALSE, cache=FALSE>>=
library(knitr)
library(cmcR) # remotes::install_github("CSAFE-ISU/cmcR@dev")
library(impressions) # remotes::install_github("jzemmels/impressions")
library(patchwork)
library(x3ptools)
library(raster) #install.packages("raster")
library(tidyverse)
theme_set(theme_bw())

# source("code/fiveplot.r")

knitr::opts_chunk$set(
  fig.path="figures/", echo=FALSE,
  out.width = '\\linewidth',
  fig.align = "center",
  fig.pos = "htbp",
  strip.white = TRUE,
  warning=TRUE, #FALSE, # better show warnings in general
  cache = TRUE)

# load("data/topMatchExampleScans.RData")
# load("data/patchComparisonFeatures.RData")

nonMatch_processed <- x3ptools::x3p_read("data/K002eG1_processed.x3p")
source_processed <- x3ptools::x3p_read("data/K013sA1_processed.x3p") %>%
  x3p_interpolate(resx = nonMatch_processed$header.info$incrementX,resy = nonMatch_processed$header.info$incrementY)
target_processed <- x3ptools::x3p_read("data/K013sA2_processed.x3p") %>%
  x3p_interpolate(resx = nonMatch_processed$header.info$incrementX,resy = nonMatch_processed$header.info$incrementY)
@

<<cmcResults, eval=TRUE, cache = FALSE>>=
# Requires the current dev (as of 2/14/22) version of cmcR
comparisonResults_full <-
  map2_dfr(list(target_processed,nonMatch_processed),
           c("K013sA2","K002eG1"),
           function(scan,scanName){

             map_dfr(seq(-30,30,by = 3),
                     function(theta){

                       comparison_allTogether(reference = source_processed,
                                              target = target_processed,
                                              theta = theta,numCells = c(8,8),
                                              maxMissingProp = .99,
                                              sideLengthMultiplier = 3,
                                              returnX3Ps = TRUE)

                     }) %>%
               dplyr::mutate(originalMethod = decision_CMC(cellIndex = cellIndex,x=x,y=y,theta=theta,corr=pairwiseCompCor),
                             comparisonName = paste0("K013sA1 vs. ",scanName))

           })

comparisonResults <- comparisonResults_full %>%
  dplyr::group_by(comparisonName,cellIndex) %>%
  dplyr::filter(pairwiseCompCor == max(pairwiseCompCor)) %>%
  dplyr::ungroup()

save(comparisonResults,file = "data/comparisonResults.RData")
@

<<cmcResults_load>>=
load("data/comparisonResults.RData")
@


\section{Background and Introduction}

Forensic examinations are intended to provide an objective assessment of the probative value of a piece of evidence.
Typically, this assessment of probative value is performed by a forensic examiner who visually inspects the evidence to determine whether it matches evidence found on a suspect.
The process by which an examiner arrives at their evidentiary conclusion is largely opaque and has been criticized \citepalias{pcast} because its subjectivity does not allow for an estimation of error rates.
In response, \citet{nas} pushed to augment subjective decisions made by forensic examiners with automatic, statistically-founded algorithms that objectively assess evidence and can be explained during court testimony.
These algorithms enable the quantification of an examiner's uncertainty by measuring the probative value of a piece of evidence.

A \emph{cartridge case} (see \autoref{fig:cartridgeCaseBullet}) is the portion of firearm ammunition that encases a projectile (e.g., bullet, shots, or slug) along with the explosive used to propel the projectile through the firearm.
When a firearm is discharged, the projectile is propelled down the barrel of the firearm, while the cartridge case is forced towards the back of the barrel.
The base of the cartridge case (\autoref{fig:cartridgeCaseBase}) strikes the back wall, known as the \emph{breech face}, of the barrel with considerable force, thereby imprinting any markings on the breech face onto the cartridge case and creating the so-called \emph{breech face impressions} (see \autoref{fig:breechFaceImpressions}).
These markings have been suggested to be unique to a firearm and are used in forensic examinations to determine whether two cartridge cases have been fired by the same firearm.

\begin{figure}[hbt]
\centering
\includegraphics[width=\textwidth]{images/cartridgeCaseZoomIn.png}
\subfloat[\label{fig:cartridgeCaseBullet} Fired cartridge case and bullet \citep{firearm_id_thompson}]{\hspace{.27\linewidth}}
\hspace{.06\linewidth}
\subfloat[\label{fig:cartridgeCaseBase} Base of the cartridge case that comes into contact with the breech face of the firearm \citep{firearmsToolmarksOverview}]{\hspace{.273\linewidth}}
\hspace{.07\linewidth}
\subfloat[\label{fig:breechFaceImpressions}  Zoom into the \emph{primer} region showing breech face impressions \citep{fadul}]{\hspace{.31\linewidth}}\newline
\caption{\label{fig:cartridgeCaseZoomIn} \hh{XXX some space to say something more}}
\end{figure}


We measure the surface of a cartridge case using a TopMatch-3D High-Capacity Scanner \citep{topmatch} by Cadre Forensics\texttrademark.
This scanner collects images under various lighting conditions of a gel pad into which the cartridge case surface is impressed and combines these images into a regular 2D array called a \emph{surface matrix}. Examples of two such surface matrices are shown in \autoref{fig:sourceAnnotated} and \autoref{fig:targetAnnotated}.
The physical dimensions of these objects are about 5.5 $mm^2$ captured at a resolution of 1.84 microns per pixel (1000 microns equals 1 mm).
Each element of the surface matrix corresponds to the height of the impressed gel at that location.
The nominal resolution for height measurements depends on the viscosity of the gel and is reported to be better than 1 micron.
The breech face impression regions have been manually annotated (in red).
Using this manual annotation, we isolate the breech face impression region.
Note that this introduces structurally missing values into the scan.

\autoref{fig:processedSideBySide} shows the isolated breech face impression regions where the height values of the surface have been mapped to a diverging purple (low) to orange (high) color scale and missing values are shown in gray.
\hh{Note that due to the scanning process the physical location of any measured values is relative, but the relationship of the measurements to each other is fixed. This means that we can, without affecting any structures, translate and even rotate measurements in 3d space. For the purpose of making scans comparable to each other, the scan surfaces are translated into XXXX what is being done exactly?} \jz{XXX I'm not sure what step in the algorithm you're referring to here. By "translated into," do you mean a horizontal/vertical shift? }\hh{Yes, I used translation in a mathematical sense here, so any shift in x, y or z direction. Sometimes we do these steps implicitly rather than in an explicit ... this is a step way. e.g. by changing from a grid to matrix we lose the physical extensions in x and y. Those are replaced by integer values first, and then rescaled into micron measurements later. That is an implicit translation in x and y. shifting a scan into a mean zero is an explicit translation, just as shifting a breech face impression is. I would very much like to use a robust estimate of the 2d breech face surface as the zero plane.} \hh{their mean and any tilts in xy direction are removed. While those tilts might stem from a small misalignments of the breech face, a bigger source of variability stems from a slight misalignment during the scanning. }

\subsubsection*{Notational Conventions}

As the name implies, surface matrices are two-dimensional arrays whose elements contain relative height values of the corresponding cartridge case surface \citep{x3p}.
For notational simplicity, we assume that the matrices are square, i.e. $A \in \R^{k \times k}$ for some matrix $A$ and $k > 0$.
Note, that any assumption of sizing of matrices are easily enforced by  padding with additional missing values. Due to the presence  of (structural) missing values around the breech face impression, additional padding does not interfere with the structure of the scan.
We use lowercase letters with subscripts to denote a particular value of a matrix; e.g., $a_{ij}$ is the value in the $i$th row and $j$th column, starting from the top left corner, of $A$.

For the purpose of dealing with missing values mathematically, we adapt standard matrix algebra as follows: if an element of either matrix $A$ or $B$ is missing, then any element-wise operation including this element is also missing, otherwise standard matrix algebra holds.
For example, for matrices $A$ and $B \in \R^{k \times k}$ we define the addition operator as:
\[
A \oplus_{\tiny{NA}} B = \left( a_{ij} \oplus_{\tiny{NA}} b_{ij} \right)_{1 \le i,j \le k} :=
\begin{cases}
a_{ij} + b_{ij} & \text{ if both } a_{ij} \text{ and } b_{ij} \text{ are numbers}\\
\text{NA } & \text{ otherwise}
\end{cases}
\]
Operations $\ominus_{\tiny{NA}}$ as well as all comparisons are defined similarly. For the purpose of readability, we will use the standard algebraic operators $+, -, >, <, ...$ and apply the extended operations as defined above.


<<matchPairExample, eval=TRUE,include=FALSE>>=
data.frame(x=1:2,y=1:2,value=c(1,1)) %>%
  x3ptools::df_to_x3p() %>%
  x3ptools::x3p_image()

x3ptools::read_x3p("data/NIST_K013sA1.x3p") %>%
  x3ptools::x3p_sample(m=4) %>%
  x3ptools::x3p_rotate() %>%
  x3ptools::x3p_flip_y() %>%
  x3ptools::x3p_rotate(angle = 270) %>%
  x3ptools::x3p_image(size = c(750,750),zoom=.75)
x3ptools::x3p_snapshot(file = "figures/topMatchAnnotatedSource.png")

x3ptools::read_x3p("data/NIST_K013sA2.x3p") %>%
  x3ptools::x3p_sample(m=4) %>%
  x3ptools::x3p_rotate() %>%
  x3ptools::x3p_flip_y() %>%
  x3ptools::x3p_rotate(angle = 270) %>%
  x3ptools::x3p_image(size = c(750,750),zoom=.75)
x3ptools::x3p_snapshot(file = "figures/topMatchAnnotatedTarget.png")

x3pPlts <- cmcR::x3pListPlot(list("K013sA1" = source_processed,
                                  "K013sA2" = target_processed)
                             ,type = "list",na.value = "gray65") %>%
  map(~ {

    . + theme(legend.position = "none",plot.title = element_text(hjust = .5))

  })


x3pCombinedPlt <- (x3pPlts[[1]]+
                     theme(plot.title = element_text(vjust = -32,
                                                     hjust = .6,
                                                     size = 18))) /
  (x3pPlts[[2]] +
     theme(plot.title = element_text(vjust = -32,
                                     hjust = .6,
                                     size = 18)))

ggsave(plot = x3pCombinedPlt,filename = "figures/sourceTargetSideBySide.png",bg ="white")

knitr::plot_crop("figures/sourceTargetSideBySide.png")

knitr::plot_crop("figures/topMatchAnnotatedSource.png")
knitr::plot_crop("figures/topMatchAnnotatedTarget.png")
@


\begin{figure}
\centering
\begin{subfigure}[c]{0.35\textwidth}
K013sA1 \hfill\newline
\includegraphics[width=\textwidth]{figures/topMatchAnnotatedSource.png}
\caption{Cartridge case scan K013sA1 with breech face (BF) impressions manually annotated in red.}
\label{fig:sourceAnnotated}
\end{subfigure}
\begin{subfigure}[c]{0.2\textwidth}
\includegraphics[width=\textwidth]{figures/sourceTargetSideBySide.png}
\caption{Processed surface matrices.}
\label{fig:processedSideBySide}
\end{subfigure}
\begin{subfigure}[c]{0.35\textwidth}
K013sA2 \hfill\newline
\includegraphics[width=\textwidth]{figures/topMatchAnnotatedTarget.png}
\caption{Cartridge case scan K013sA2 with breech face (BF) impressions manually annotated in red.}
\label{fig:targetAnnotated}
\end{subfigure}
\caption{Raw scans (left and right) and processed versions of the surface matrices (in the middle) for a pair of cartridge cases fired by the same handgun \cite[Ruger SR9, Gun A1, SerialNo 331-96383;][]{Baldwin}.}
\label{fig:annotatedBFImpressions}
\end{figure}



\hh{XXX Great! It feels like we have reached the end of the introduction. }
\hh{todo list: (1) problem statement, (2) outline what this paper is about and order in which we go about it. XXX We probably have to go back to this a couple times. }

\jz{Problem statement (draft): Can we characterize when a cartridge case alignment fails?}

\jz{Even among matching cartridge case pairs, we have found results like those shown in \autoref{fig:cmcPlot_match}, where only a small number of the total cells are classified as CMCs, to be quite common.
An underlying assumption of the CMC methodology is that many source cells should find the "correct" registration in a matching target scan.
However, it can be difficult to determine why a particular cell did or did not register correctly.
In this paper, we introduce diagnostic tools that can be used to visually and numerically characterize the quality of alignment of cells.
We also demonstrate how the numerical diagnostics can be used as features to classify matching and non-matching cartridge case pairs.}

\jz{Paper outline (draft):}

\begin{itemize}
\item \jz{Define cell-based registration procedure, use algorithm environment as in JDSSV paper}

\item \jz{Visual Diagnostics}

\begin{itemize}
\item \jz{Discuss comparison plot}

\item \jz{Define diagnostic statistics}

\item \jz{discuss connections between visual diagnostic and diagnostic statistics}
\end{itemize}

\item \jz{cartridgeInvestigatR application}

\item \jz{Conclusion}
\end{itemize}

\subsubsection*{Registration Procedure}

\jz{Describe the general registration and cell-based comparison procedures here.
Introduce terminology like "source" and "target" scans, direction subscripting, cell subscripting notation}

\jz{NOTE: need to tweak the text below, which was copied directly from the JDSSV submission}

A critical step in comparing $A$ and $B$ is to find a transformation of $B$ such that it aligns best to $A$ (or vice versa).
In image processing, this is called *image registration.* Noting that $A$ and $B$ are essentially grayscale images, we rely on a standard image registration technique \citep{Brown1992}.

In our application, a registration is composed of a discrete translation by $(m,n) \in \mathbb{Z}^2$ and rotation by $\theta \in [-180^\circ,180^\circ]$.
To determine the optimal registration, we calculate the *cross-correlation function* (CCF) between $A$ and $B$, which measures the similarity between $A$ and $B$ for every possible translation of $B$, denoted $(A \star B)$.
We estimate the registration by calculating the maximum CCF value across a range of rotations of matrix $B$.
Let $B_\theta$ denote $B$ rotated by an angle $\theta \in [-180^\circ,180^\circ]$ and $b_{\theta_{mn}}$ the $m,n$-th element of $B_\theta$.
Then the estimated registration $(m^*,n^*,\theta^*)$ is:

\begin{align*}
(m^*,n^*,\theta^*) = \arg \max_{m,n,\theta} (a \star b_\theta)_{mn}.
\end{align*}

In practice we consider a discrete grid of rotations $\pmb{\Theta} \subset [-180^\circ,180^\circ]$.
The registration procedure is outlined in \autoref{alg:registration}.
We refer to the matrix that is rotated as the "target."
The result is the estimated registration of the target matrix to the "source" matrix.

\begin{algorithm}[htbp]
\KwData{Source matrix $A$, target matrix $B$, and rotation grid $\pmb{\Theta}$}
\KwResult{Estimated registration of $B$ to $A$, $(m^*,n^*,\theta^*)$, and cross-correlation function maximum, $CCF_{\max}$}
\For{$\theta \in \pmb{\Theta}$}{
Rotate $B$ by $\theta$ to obtain $B_\theta$\;
Calculate $CCF_{\max, \theta} = \max_{m,n} (a \star b_{\theta})_{mn}$\;
Calculate translation $[m^*_\theta,n^*_\theta] = \arg \max_{m,n} (a \star b_{\theta})_{mn}$
}
Calculate overall maximum correlation $CCF_{\max} = \max_{\theta} \{CCF_{\max,\theta} : \theta \in \pmb{\Theta}\}$\;
Calculate rotation $\theta^* = \arg \max_{\theta} \{CCF_{\max,\theta} : \theta \in \pmb{\Theta}\}$\;
\Return{Estimated rotation $\theta^*$, translation $m^* = m^*_{\theta^*}$ and $n^* = n^*_{\theta^*}$, and $CCF_{\max}$}
\caption{Image Registration Procedure}
\label{alg:registration}
\end{algorithm}

\jz{[Song (2013)] points out that two matching cartridge cases may only have a handful of regions with distinguishable, matching impressions due to inherent variability in the firing process.
Calculating a correlation between two full scans as in \autoref{alg:registration} may not highlight their similarities.
Instead, [Song (2013)] proposes partitioning one of the scans into a grid of "cells" and estimating the registration between each cell and the other scan.}

We now extend the surface matrix notation introduced previously to accommodate cells.
Let $A_{t}$ denote the $t$th cell of matrix $A$, $t = 1,...,T_A$ where $T_A$ is the total number of cells containing non-missing values (e.g., $T_A = 43$ in \autoref{fig:cellGridExample}) in scan $A$ and let $(a_t)_{ij}$ denote the $i,j$-th element of $A_t$.
This procedure can be viewed as a generalization of \autoref{alg:registration} that we call the "cell-based comparison procedure" and outline in \autoref{alg:cellComparison}.

\begin{algorithm}[H]
\KwData{Source matrix $A$, target matrix $B^*$, cell grid size $R \times C$, and rotation grid $\pmb{\Theta}'_A$}
\KwResult{Estimated translations and $CCF_{\max}$ values per cell, per rotation}
Partition $A$ into a grid of $R \times C$ cells\;
Discard cells containing only missing values, leaving $T_A$ remaining cells\;
\For{$\theta \in \pmb{\Theta}'_A$}{
Rotate $B^*$ by $\theta$ to obtain $B^*_\theta$\;
\For{$t = 1,...,T_A$}{
Calculate $CCF_{\max, A,t,\theta} = \max_{m,n} (a_t \star b^*_\theta)_{mn}$\;
Calculate translation $[m^*_{A,t,\theta},n^*_{A,t,\theta}] = \arg \max_{m,n} (a_t \star b^*_\theta)_{mn}$
}
}
\Return{$\pmb{F}_A = \{(m^*_{A,t,\theta},n^*_{A,t,\theta}, CCF_{\max,A,t,\theta}, \theta) : \theta \in \pmb{\Theta}'_A, t = 1,...,T_A\}$}
\caption{Cell-Based Comparison Procedure}
\label{alg:cellComparison}
\end{algorithm}

\jz{TODO: Show a figure of the cell-based comparison results. Make it a cmcPlot where all cells are gray}

% <<cmcPlot, eval=TRUE,include=FALSE>>=
% matchingCMCPlt <- cmcR::cmcPlot(
%   reference = source_processed,
%   target = target_processed,
%   cmcCol = "originalMethod",
%   cmcClassifs = comparisonResults %>%
%     filter(comparisonName == "K013sA1 vs. K013sA2")
% )
%
% design <-
%   "AB"
%
% cmcPltCombined <-
%   patchwork::wrap_plots(
%     matchingCMCPlt[[1]] +
%       theme(strip.text = element_blank(),
%             plot.margin = margin(0,0,-20000,0),
%             plot.subtitle = element_text(hjust = .5,size = 12,vjust=-50)) +
%       annotation_custom(grid::textGrob(label="Source\nK013sA1")),
%     #  labs(subtitle = "Source: K013sA1"),
%     matchingCMCPlt[[2]] +
%       theme(strip.text = element_blank(),
%             plot.margin = margin(0,0,-20000,0),
%             plot.subtitle = element_text(hjust = .57,size = 12,vjust=-50)) +
%       annotation_custom(grid::textGrob(label="Target\nK013sA2", x = unit(0.6, "npc"))),
%     #  labs(subtitle = "Target: K013sA2"),
%     design = design,widths = c(.88,1)) +
%   patchwork::inset_element(matchingCMCPlt[[3]],left = -.85,bottom = -.6,right = 1,top = 1,align_to = "full")
%
% ggsave('figures/cmcPlot.png', plot = cmcPltCombined,
%        width = 7.53*.75, height = 6.67*.75)
% knitr::plot_crop("figures/cmcPlot.png")
% @
%
% <<echo=FALSE,fig.cap='\\label{fig:cmcPlot_match} Congruent Matching Cell classifications from comparing two matching cartridge cases. CMCs are shown in blue and correspond to source scan cells that reach a consensus on the registration angle and translation in the target scan. Non-CMCs are shown in red and represent the registration at which the registration cells attain their largest CCF value across all rotations and translations considered.',fig.pos='htbp',out.width=".8\\textwidth", fig.align = 'center', cache=FALSE>>=
% knitr::include_graphics("figures/cmcPlot.png")
% @

\section{Visual Diagnostics}

\subsection{Comparison Plots}

To create the visual diagnostics, we perform element-wise matrix operations.
In particular, for a matrix $X \in \mathbb{R}^{k \times k}$ and condition $cond: \mathbb{R}^{k \times k} \to \{TRUE,FALSE\}^{k \times k}$, we define an element-wise filter operation $\mathcal{F}: \mathbb{R}^{k \times k} \to \mathbb{R}^{k \times k}$ as:
\begin{align*}
\mathcal{F}_{cond}(X) =
(f_{ij})_{1 \leq i,j \leq k} =
\begin{cases}
x_{ij} &\text{if $cond$ is $TRUE$ for element $i,j$} \\
NA &\text{otherwise}
\end{cases}
\end{align*}
Of particular interest in our application is the (absolute) difference between surface matrices.
For example, $\mathcal{F}_{|A - B| > \tau}(A)$ contains elements of matrix $A$ where the pair of scans $A$ and $B$ deviate by at least $\tau \in \mathbb{R}$.
Surface values in $A$ and $B^*$ that are "close," meaning within $\tau$ distance, to each other are replaced with $NA$ in this filtered matrix.

Consider \autoref{fig:filterLabeling} that shows the filtered element-wise average $\mathcal{F}_{|A - B^*| < \tau}\left(\frac{1}{2}(A + B^*)\right)$ on the left and the associated $cond$ matrix $|A - B^*| < \tau$ visualized in black-and-white in the middle where filtered elements are shown in white.
We use a connected components labeling algorithm detailed in [Haralick and Shapiro (1992)] to identify individual neighborhoods of filtered elements.
More precisely, the algorithm returns a set of sets $\pmb{S}_d = \{S_{d,1},S_{d,2},...,S_{d,L_d}\}$ where each $S_{d,l}$ is a set of indices of the $cond$ matrix that have a value of $TRUE$ and are connected by a chained-together sequence of 4 (Rook's) neighborhoods.
The right side of \autoref{fig:filterLabeling} shows each $S_{d,l}$ distinguished by different fill colors, $l = 1,...,L_d$.

<<fullScanComparisonCalculation,cache=TRUE>>=
fullScan_comparisonData <- map_dfr(seq(-30,30,by = 3),
                                   function(theta){

                                     source_processed %>%
                                       comparison_allTogether(target = target_processed,
                                                              theta = theta,
                                                              numCells = c(1,1),
                                                              maxMissingProp = .99,
                                                              sideLengthMultiplier = 1.1,
                                                              returnX3Ps = TRUE)

                                   }) %>%
  filter(fft_ccf == max(fft_ccf)) %>%
  mutate(comparisonName = "K013sA1 vs. K013sA2")
@

<<fullScanComparisonPlot,include = FALSE,cache=TRUE>>=
source <- fullScan_comparisonData %>%
  pull(cellHeightValues) %>%
  .[[1]]

target <- fullScan_comparisonData %>%
  pull(alignedTargetCell) %>%
  .[[1]]

patchComparisonPlts_combined <-
  impressions::x3p_comparisonPlot(x3p1 = source,x3p2 = target,
                                  plotLabels = c("K013sA1","K013sA2\nAligned",
                                                 "Element-wise Average",
                                                 "K013sA1\nDifferences",
                                                 "K013sA2\nAligned Differences"),
                                  labelSize = 2.5,
                                  legendLength = grid::unit(4,"in"))

ggsave(plot = patchComparisonPlts_combined,filename = "figures/complementCompPlot_fullScan.png",
       width = 7,height = 7,bg = "white")
knitr::plot_crop("figures/complementCompPlot_fullScan.png")
@

<<>>=
compPlt <- patchComparisonPlts_combined

plt1 <- compPlt$patches$plots[[3]]

plt1$layers[[3]] <- NULL

scanFilterBinarized <- source %>%
  impressions::x3p_elemAverage(target) %>%
  impressions::x3p_to_dataFrame() %>%
  mutate(value = (abs(c({source$surface.matrix - target$surface.matrix})) > x3p_sd(source,target)))

plt2 <- scanFilterBinarized %>%
  ggplot(aes(x=x,y=y,fill=value)) +
  geom_raster() +
  scale_fill_manual(values = c("black","white"),na.value = "gray65") +
  coord_fixed(expand = FALSE) +
  theme_void() +
  theme(legend.position = "none")


scanFilterLabeled <- scanFilterBinarized %>%
  mutate(x = x + 1,y = y + 1,
         value = ifelse(!value | is.na(value),0,1)) %>%
  imager::as.cimg() %>%
  imager::label() %>%
  as.data.frame() %>%
  mutate(value = factor(value))

plt3 <- scanFilterLabeled %>%
  ggplot(aes(x=x,y=y,fill=value)) +
  geom_raster() +
  coord_fixed(expand = FALSE) +
  theme_void() +
  theme(legend.position = "none") +
  scale_fill_manual(values = c("gray65",sample(RColorBrewer::brewer.pal(12,"Paired"),size = length(unique(scanFilterLabeled$value)) - 1,replace = TRUE)))

labeledBlobPlts_combined <- (plt1 + plt2 + plt3) & theme(panel.border = element_rect(colour = "black",fill = NA))

ggsave(plot = labeledBlobPlts_combined,filename = "figures/binarizedBlobs.png",bg = "white")
knitr::plot_crop("figures/binarizedBlobs.png")
@

<<>>=
knitr::include_graphics("figures/binarizedBlobs.png")
@


<<matchCCP_combine, eval=TRUE,cache=FALSE,include=FALSE>>=
refCell <- comparisonResults %>%
  filter(cellIndex == "3, 8") %>%
  slice(1) %>%
  pull(cellHeightValues) %>%
  .[[1]]

targCell <- comparisonResults %>%
  filter(cellIndex == "3, 8") %>%
  slice(1) %>%
  pull(alignedTargetCell) %>%
  .[[1]]

patchComparisonPlts_combined <- impressions::x3p_comparisonPlot(
  x3p1 = refCell,x3p2 = targCell,labelSize = 3,
  plotLabels = c("K013sA1 Cell 3, 8",
                 "K013sA2 Aligned Cell",
                 "Element-wise Average",
                 "K013sA1 Cell 3, 8\nDifferences",
                 "K013sA2 Aligned Cell\nDifferences"))

ggsave(plot = patchComparisonPlts_combined,filename = "figures/complementCompPlot.png",
       width = 7,height = 7,bg = "white")
knitr::plot_crop("figures/complementCompPlot.png")
@

<<matchCCP_show, out.width=".9\\textwidth",fig.cap="\\label{fig:fivePlotComparison} The complementary comparison plot for two cells from the comparison between cell 3, 8 of scan K013sA1 and its aligned mate in scan K013sA2. The left column shows the surface values of these two cells. Note that non-overlapping pixels are shown in dark gray in the bottom left plot. The middle column shows similarities between the surfaces in the form of the filtered element-wise average. The right column shows the surface values with the opposite filtering used in the filtered element-wise average plot. A gray border is used to emphasize the filtered vs. non-filtered regions.", cache=FALSE>>=
knitr::include_graphics("figures/complementCompPlot.png")
@



% \section{Visual Diagnostic Feature Extraction}
%
% \jz{List of features so far XXX}
% \begin{itemize}
%
% \item \jz{Amount of overlap between the two aligned cells. XXX should this be \# of elements in their intersection over \# of elements in their union? XXX}
%
% \item \jz{Average value amongst the filtered element-wise averages.}
%
% \item \jz{XXX what's a better feature to calculate from the filtered element-wise average? XXX}
%
% \item \jz{Correlation between the filtered differences plot}
%
% \item \jz{XXX Some sort of weighted difference between the two scans. If we have a difference of 10, say, we care less if this is a difference between 15 and 25, which point in the same "direction", than -5 and 5. Think of what this weighting function might look like. XXX}
%
% \item \jz{XXX Broadly, we want to ensure that cells are classified as CMCs/non-CMCs *for the right reason.* Using the "aligned ants" plot, determine which areas of the scan(s) are "influential" in that they attract a large number of cells. This will help us "weigh" whether a particular cell's classification as a CMC should be trusted (e.g., if there are many cells that attract to that spot, then perhaps we should trust it less). Conversely, think about a way to determine when a cell is classified as a non-CMC, yet still is extremely similar to its aligned cell (perhaps this is what the complementary comparison plot features measure?). Not all areas of the scan(s) are of the same "importance," so figuring out what "important" means will help us explain why a cell is classified as a CMC while another isn't.XXX}
%
%
% \end{itemize}
%
% We assume that well-aligned cells from truly matching cartridge case pairs will on average be more similar than aligned cells from non-matching cartridge case pairs.
% Below, we summarize a set of features used to quantify this notion of similarity.
%
% \jz{Amount of overlap between the two aligned cells = the number of elements that are observed in both $A$ and $B$ divided by the number of elements that are observed in either $A$ or $B$ (intersection/union)}
%
% % Define the observed value indicator function $O(x) = I(\text{$x$ is a number})$.
% Then define the proportion of overlapping elements as the size of the intersection of observed values divided by the size of the union of observed values between $A$ and $B$:
% \begin{align*}
% p_{overlap} = \frac{\sum_{i=1}^r \sum_{j=1}^c O(a_{ij}) O(b_{ij})}{\sum_{i=1}^r \sum_{j=1}^c O(a_{ij}) + O(b_{ij}) - O(a_{ij}) O(b_{ij})}.
% \end{align*}
% We assume that the surface values in well-aligned cells from truly matching cartridge cases will overlap more than in non-matching cells.
%
% \jz{Correlation between the filtered differences plot}
%
% For two matrices $A$ and $B$, we also consider the correlation between the filtered matrices:
% \begin{align*}
% c_f = Corr(\mathcal{F}_{|A-B| > \tau}(A),\mathcal{F}_{|A-B| > \tau}(B)).
% \end{align*}
% The correlation is calculated by vectorizing $\mathcal{F}_{|A-B| > \tau}(A)$ and $\mathcal{F}_{|A-B| > \tau}(B)$ and treating missing values by case-wise deletion.
% We assume that the correlation between the filtered matrices will be larger if $A$ and $B$ are well-aligned matching pairs than if they are non-matching pairs.
% Said another way, even in regions where matching cells are different from each other, we assume that the height values will follow similar trends.
% This can occur due to variability in the amount of contact between a cartridge case and the breech face across multiple fires from the same firearm.
%
% We also consider features based on the elements of the absolute difference filters $\mathcal{F}_{|A-B| > \tau}(A)$ and $\mathcal{F}_{|A-B| > \tau}(B)$.
% The left of \autoref{fig:filteredElements} shows $\mathcal{F}_{|A_{38} - B_{38}| > 1.4}(A_{38})$.
% In the middle of \autoref{fig:filteredElements}, we show the filtered and non-filtered elements of $\mathcal{F}_{|A_{38} - B_{38}| > 1.4}(A_{38})$ in white and black, respectively.
%
% <<include=FALSE>>=
% compPlt <- impressions::x3p_comparisonPlot(
%   x3p1 = refCell,
%   x3p2 = targCell,
%   plotLabels = c("Scan A","Scan B*","Filtered Element-wise\nAverage",
%                  "Scan A\nFiltered\nDifferences","Scan B*\nFiltered\nDifferences"),
%   labelSize = 2.5,
%   legendLength = grid::unit(4,"in"),
%   legendHoriz = -1.3,
%   legendQuantiles = c(0,.01,.05,.5,.95,.99,1))
%
% plt1 <- compPlt$patches$plots[[3]]
%
% plt1$layers[[3]] <- NULL
%
% scanFilterBinarized <- refCell %>%
%   impressions::x3p_elemAverage(targCell) %>%
%   impressions::x3p_to_dataFrame() %>%
%   mutate(value = (abs(c({refCell$surface.matrix - targCell$surface.matrix})) > x3p_sd(refCell,targCell)))
%
% plt2 <- scanFilterBinarized %>%
%   ggplot(aes(x=x,y=y,fill=value)) +
%   geom_raster() +
%   scale_fill_manual(values = c("black","white"),na.value = "gray65") +
%   coord_fixed(expand = FALSE) +
%   theme_void() +
%   theme(legend.position = "none")
%
%
% scanFilterLabeled <- scanFilterBinarized %>%
%   mutate(x = x + 1,y = y + 1,
%          value = ifelse(!value | is.na(value),0,1)) %>%
%   imager::as.cimg() %>%
%   imager::label() %>%
%   as.data.frame() %>%
%   mutate(value = factor(value))
%
% plt3 <- scanFilterLabeled %>%
%   ggplot(aes(x=x,y=y,fill=value)) +
%   geom_raster() +
%   coord_fixed(expand = FALSE) +
%   theme_void() +
%   theme(legend.position = "none") +
%   scale_fill_manual(values = c("gray65",sample(RColorBrewer::brewer.pal(12,"Paired"),size = length(unique(scanFilterLabeled$value)) - 1,replace = TRUE)))
%
% labeledBlobPlts_combined <- (plt1 + plt2 + plt3) & theme(panel.border = element_rect(colour = "black",fill = NA))
%
% ggsave(plot = labeledBlobPlts_combined,filename = "figures/binarizedBlobs.png",bg = "white")
% knitr::plot_crop("figures/binarizedBlobs.png")
% @
%
% <<blobPlots_show,fig.cap="\\label{fig:filteredElements} From left to right: the absolute difference filtered visualization of cell 3, 8 in scan K013sA1, a visualization of the filtered elements where white pixels correspond to element-wise absolute differences larger than 1.4, and a visualization of the connected regions of filtered elements that have been labeled using a connected components labeling algorithm.", cache=FALSE>>=
% knitr::include_graphics("figures/binarizedBlobs.png")
% @
%
% Letting $M = \{(i,j) : O(f_{ij}) = 1\}$ denote the set of non-missing elements of $\mathcal{F}_{|A-B| > \tau}(A)$, consider the number of filtered elements as a proportion of the total number of non-missing values:
% \begin{align*}
% p_{filtered} = \frac{\sum_{(i,j) \in M} f_{ij}}{|M|}
% \end{align*}
% where $|M|$ is the cardinality of $M$.
% We assume that fewer elements will be filtered from matching cell pairs than non-matching.
%
% \jz{XXX Average and standard deviation of blob sizes}
%
% We use the connected components labeling algorithm detailed in \citet{haralick_shapiro} to individually identify neighborhoods of filtered elements.
% More precisely, the labeling algorithm provides a set of sets $\pmb{B} = \{B_1,B_2,...,B_{L}\}$ where each element $B_l$ consists of indices of $\mathcal{F}_{|A-B| \leq \tau}(A)$ that are connected by a chained-together sequence of 4 (or Rook's) neighborhoods.
% For the black and white filtered elements shown in the middle of \autoref{fig:filteredElements}, the right plot depicts the $B_l$ neighborhoods distinguished by fill colors.
% We consider the average and standard deviation of the neighborhood sizes as another feature:
% \begin{align*}
% \bar{B} &= \frac{1}{L} \sum_{l=1}^L |B_l| \\
% \sigma_B &= \sqrt{\frac{1}{L-1} \sum_{l=1}^L (|B_l| - \bar{B})^2}
% \end{align*}
% where $|B_l|$ is the cardinality of $B_l$.
% We assume that neighborhoods of filtered elements will be smaller on average and exhibit less variability for well-aligned matching cells compared to non-matching cells.
%
% \section{Results}
%
% % For two scans $A$ and $B$, we first consider applying the CMC method described above using the entire scans ($k = 1$) instead of partitioning the scans into a grid of cells.
% % Using the cross-correlation as an optimization criterion, we obtain an estimated registration $(\hat{\theta}_{11}, \widehat{dx}_{11}, \widehat{dy}_{11})$ at which $A$ and $B$ are most similar.
% % Note that in this case, if $(\hat{\theta}_{11}, \widehat{dx}_{11}, \widehat{dy}_{11})$ is the registration that aligns scan $B$ to $A$, then $(-\hat{\theta}_{11}, -\widehat{dx}_{11}, -\widehat{dy}_{11})$ aligns $A$ to $B$.
% \jz{For two scans $A$ and $B$, we apply the following procedure:}
% \begin{enumerate}
% \item \jz{Identify the registration $(\hat{\theta},\widehat{dx}, \widehat{dy})$ that maximizes the cross-correlation between scan $A$ and $B$. Assume that $(\hat{\theta},\widehat{dx}, \widehat{dy})$ aligns scan $B$ to scan $A$ (meaning $(-\hat{\theta},-\widehat{dx},-\widehat{dy})$ align $A$ to $B$).}
%
% \item \jz{Apply $(\hat{\theta},\widehat{dx}, \widehat{dy})$ to scan $B$.}
%
% \item \jz{Partition $A$ into a grid of $4 \times 4$ cells, $\{A_{11}, A_{12},...,A_{44}\}$. Identify the matching cells $\{B_{11}, B_{12},...,B_{44}\}$ by maximizing the cross-correlation function.}
%
% \item \jz{Calculate the visual diagnostic features for each cell pair.}
%
% \item \jz{Repeat steps 1-4 using scan $B$ as the source scan.}
% \end{enumerate}
%
% \autoref{fig:fivePlotComparison_fullScan} shows the complementary comparison plot comparing scan K013sA1 and K013sA2 where $(\hat{\theta}, \widehat{dx}, \widehat{dy}) = (3, -14, -11)$.
% Notice that K013sA2 has been "cropped" after applying the estimated registration to be the same size as K013sA1.
%
% <<fullScanComparisonCalculation,cache=TRUE>>=
% fullScan_comparisonData <- map_dfr(seq(-30,30,by = 3),
%                                    function(theta){
%
%                                      source_processed %>%
%                                        comparison_allTogether(target = target_processed,
%                                                               theta = theta,
%                                                               numCells = c(1,1),
%                                                               maxMissingProp = .99,
%                                                               sideLengthMultiplier = 1.1,
%                                                               returnX3Ps = TRUE)
%
%                                    }) %>%
%   filter(fft_ccf == max(fft_ccf)) %>%
%   mutate(comparisonName = "K013sA1 vs. K013sA2")
% @
%
% <<fullScanComparisonPlot,include = FALSE,cache=TRUE>>=
% source <- fullScan_comparisonData %>%
%   pull(cellHeightValues) %>%
%   .[[1]]
%
% target <- fullScan_comparisonData %>%
%   pull(alignedTargetCell) %>%
%   .[[1]]
%
% patchComparisonPlts_combined <-
%   impressions::x3p_comparisonPlot(x3p1 = source,x3p2 = target,
%                                   plotLabels = c("K013sA1","K013sA2\nAligned",
%                                                  "Element-wise Average",
%                                                  "K013sA1\nDifferences",
%                                                  "K013sA2\nAligned Differences"))
%
% ggsave(plot = patchComparisonPlts_combined,filename = "figures/complementCompPlot_fullScan.png",
%        width = 7,height = 7,bg = "white")
% knitr::plot_crop("figures/complementCompPlot_fullScan.png")
% @
%
% <<matchCCP_fullScan_show, out.width=".9\\textwidth",fig.cap="\\label{fig:fivePlotComparison_fullScan} The complementary comparison plot for comparing scan K013sA1 and the aligned scan K013sA2. The left column shows the surface values of the two scans. The middle column shows similarities between the surfaces in the form of the filtered element-wise average. The right column shows the surface values with the opposite filtering used in the filtered element-wise average plot. A gray border is used to emphasize the filtered vs. non-filtered regions.", cache=FALSE>>=
% knitr::include_graphics("figures/complementCompPlot_fullScan.png")
% @
%
% <<visualDiagnosticResultsPlot,include=FALSE>>=
% load("data/visualDiagnosticFeatures_fullScans.RData")
%
% resultsPlt <- visualDiagnosticFeatures_fullScans %>%
%   filter(sdMultiplier == 1) %>%
%   select(type,8:15) %>%
%   mutate(x = log10(abs(x)),
%          y = log10(abs(y)),
%          theta = abs(theta),
%          blobSize_ave_nonStandardized = log10(blobSize_ave_nonStandardized),
%          blobSize_sd_nonStandardized = log10(blobSize_sd_nonStandardized)) %>%
%   pivot_longer(cols = 2:9) %>%
%   mutate(name = str_remove(name,"_nonStandardized")) %>%
%   mutate(name = factor(name,
%                        levels = c("blobSize_ave","blobSize_sd","differenceCor","theta","x","y","fft_ccf","pairwiseCompCor"),
%                        labels = c("Average Neighborhood Size\nLog10 scale",
%                                   "Neighborhood Size S.D.\nLog10 scale",
%                                   "Filtered Difference Cor.",
%                                   "Estimated Rotation",
%                                   "Absolute Horiz. Translation\nLog10 scale",
%                                   "Absolute Vert. Translation\nLog10 scale",
%                                   "FFT-based CCF",
%                                   "Pairwise-complete Cor."))) %>%
%   ggplot(aes(x = name,y = value,fill = type)) +
%   geom_boxplot() +
%   facet_wrap(~ name,scales = "free") +
%   labs(fill = "Comparison Type") +
%   theme_bw() +
%   theme(legend.position = "bottom",
%         axis.title = element_blank(),
%         axis.text.x = element_blank(),
%         axis.ticks.x = element_blank()) +
%   guides(fill = guide_legend(nrow = 1))
%
% ggsave(plot = resultsPlt,filename = "figures/resultsPlt.png")
% knitr::plot_crop("figures/resultsPlt.png")
% @
%
% <<visualDiagnosticResultsPlot_show,out.width=".9\\textwidth",fig.cap="\\label{fig:visualDiagnosticsPlot} Distribution of features.", cache=FALSE>>==
% knitr::include_graphics("figures/resultsPlt.png")
% @
%


\section{Discussion}

%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------

\bigskip
\begin{center}
{\large\bf SUPPLEMENTARY MATERIAL}
\end{center}

\begin{description}

\item[Title:] Brief description. (file type)

\item[R-package for MYNEW routine:] R-package MYNEW containing code to perform the diagnostic methods described in the article. The package also contains all datasets used as examples in the article. (GNU zipped tar file)

\item[TopMatch Example Scans:] Data set used in the illustration of MYNEW method in \autoref{diagnostics} (.txt file)

\end{description}

%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------


\bibliography{refs.bib}

%----------------------------------------------------------------------------------------
\newpage
\section*{Appendix}
\begin{appendix}
\section{Examples of CCPs}\label{additional.fives}
\hh{Include one (or more) example(s) of a five-plot ensemble for a non-match so that we can see the qualitative difference. }


% <<nonMatchCCP_create,eval=TRUE,cache=FALSE,include=FALSE>>=
% sourceCell_nonMatch <- comparisonResults %>%
%   filter(comparisonName != "K013sA1 vs. K013sA2") %>%
%   filter(cellIndex == "5, 1") %>%
%   filter(pairwiseCompCor == max(pairwiseCompCor)) %>%
%   pull(cellHeightValues) %>%
%   .[[1]]
%
% targetCell_nonMatch <- comparisonResults %>%
%   filter(comparisonName != "K013sA1 vs. K013sA2") %>%
%   filter(cellIndex == "5, 1") %>%
%   filter(pairwiseCompCor == max(pairwiseCompCor)) %>%
%   pull(alignedTargetCell) %>%
%   .[[1]]
%
% # sourceCell_nonMatch$surface.matrix <- (sourceCell_nonMatch$surface.matrix*sourceCell_nonMatch$cmcR.info$scaleByVal + sourceCell_nonMatch$cmcR.info$centerByVal)*1e6
% # targetCell_nonMatch$surface.matrix <- (targetCell_nonMatch$surface.matrix*targetCell_nonMatch$cmcR.info$scaleByVal + targetCell_nonMatch$cmcR.info$centerByVal)*1e6
%
% nonMatchCellPairThresh <- sd(c(c(sourceCell_nonMatch$surface.matrix),c(targetCell_nonMatch$surface.matrix)),na.rm = TRUE)
%
% patchComparisonPlts <- impressions::x3p_comparisonPlot(x3p1 = sourceCell_nonMatch,
%                                                       x3p2 = targetCell_nonMatch,
%                                                       plotLabels = c("K013sA1 Cell 5, 1","K002eG1 Aligned Cell\nat 3Â°",
%                                                                     "Filtered Element-wise Average",
%                                                                     "K013sA1 Cell 5, 1\nFiltered Differences","K002eG1 Aligned Cell\nFiltered Differences"),1)
%
% patchComparisonLegend_nonMatch <- cowplot::plot_grid(patchComparisonPlts$legend$grobs[[1]])
% @
%
% <<nonMatchCCP_blobs,eval=TRUE,cache=FALSE,include=FALSE>>=
% combinedValues <- comparisonResults %>%
%   filter(comparisonName != "K013sA1 vs. K013sA2") %>%
%   filter(cellIndex == "5, 1") %>%
%   filter(pairwiseCompCor == max(pairwiseCompCor)) %>%
%   pull(cellHeightValues) %>%
%   .[[1]] %>%
%   impressions::x3p_to_dataFrame() %>%
%   rename(refValue = value) %>%
%   left_join(comparisonResults %>%
%               filter(comparisonName != "K013sA1 vs. K013sA2") %>%
%               filter(cellIndex == "5, 1") %>%
%               filter(pairwiseCompCor == max(pairwiseCompCor)) %>%
%               pull(alignedTargetCell) %>%
%               .[[1]] %>%
%               impressions::x3p_to_dataFrame() %>%
%               rename(targValue = value),
%             by = c("x","y"))
%
% blobBoundaries <- comparisonResults %>%
%   filter(comparisonName != "K013sA1 vs. K013sA2") %>%
%   filter(cellIndex == "5, 1") %>%
%   filter(pairwiseCompCor == max(pairwiseCompCor)) %>%
%   dplyr::select(comparisonName,cellIndex,cellHeightValues,alignedTargetCell) %>%
%   pmap(~ {
%
%     source <- ..3
%
%     target <- ..4
%
%     source$surface.matrix <- (source$surface.matrix*source$cmcR.info$scaleByVal + source$cmcR.info$centerByVal)*1e6
%     target$surface.matrix <- (target$surface.matrix*target$cmcR.info$scaleByVal + target$cmcR.info$centerByVal)*1e6
%
%     averageBinarized <- bind_rows(source %>%
%                                     x3p_to_dataFrame() %>%
%                                     mutate(value = value),
%                                   target %>%
%                                     x3p_to_dataFrame() %>%
%                                     mutate(value = value)) %>%
%       group_by(x,y) %>%
%       summarise(difference = diff(value),
%                 absDifference = abs(diff(value)),
%                 average = mean(value),
%                 .groups = "drop")  %>%
%       mutate(comparisonName = ..1,
%              cellIndex = ..2)%>%
%       mutate(value = ifelse(absDifference > sd(c(c(sourceCell_nonMatch$surface.matrix),c(targetCell_nonMatch$surface.matrix)),na.rm=TRUE),TRUE,FALSE))
%
%     suppressWarnings({
%
%       averageMat <- averageBinarized %>%
%         mutate(x = x+1,
%                y=y+1) %>%
%         dplyr::select(x,y,value) %>%
%         imager::as.cimg() %>%
%         as.matrix()
%
%     })
%
%     averageMat[is.na(averageMat)] <- 0
%
%     # we pad the matrix so that the contours one the edge blobs are properly
%     # identified. the padding is removed in the last lines of the creation of
%     # the outline object below
%     averageMat  <- averageMat %>%
%       imager::as.cimg() %>%
%       imager::pad(nPix = 10,axes = "xy",val = 0)
%
%     labels <- imager::label(averageMat)
%
%     bounds <- map(unique(labels[labels > 0]),
%                   function(lab){
%
%                     imager::boundary(labels == lab)
%
%                   })
%
%     return(list(bounds,labels))
%
%   })
%
% # combine all labeled blobs into one image
% boundaryPx <- blobBoundaries[[1]][[1]] %>%
%   imager::as.imlist() %>%
%   imager::add()
%
% # the mask used to dilate the blobs will grow them towards the bottom-right of
% # the matrix
% dilatedPx <- imager::dilate_rect(boundaryPx,sx = 2,sy = 2)
% dilatedPx_labels <- imager::dilate_rect(blobBoundaries[[1]][[2]],sx = 2,sy = 2)
%
% # flip the image and re-apply the dilation to grow the borders to the other
% # corners. flip back after dilation
% dilatedPx_mirrorx <- imager::mirror(imager::dilate_rect(imager::mirror(boundaryPx,axis="x"),sx = 2,sy = 2),axis="x")
% dilatedPx_mirrorx_labels <- imager::mirror(imager::dilate_rect(imager::mirror(blobBoundaries[[1]][[2]],axis="x"),sx = 2,sy = 2),axis="x")
%
% dilatedPx_mirrory <- imager::mirror(imager::dilate_rect(imager::mirror(boundaryPx,axis="y"),sx = 2,sy = 2),"y")
% dilatedPx_mirrory_labels <- imager::mirror(imager::dilate_rect(imager::mirror(blobBoundaries[[1]][[2]],axis="y"),sx = 2,sy = 2),"y")
%
% dilatedPx_mirrorxy <- imager::mirror(imager::dilate_rect(imager::mirror(boundaryPx,axis="xy"),sx = 3,sy = 3),"xy")
% dilatedPx_mirrorxy_labels <- imager::mirror(imager::dilate_rect(imager::mirror(blobBoundaries[[1]][[2]],axis="xy"),sx = 3,sy = 3),"xy")
%
% # combine all of the dilated images together into one image
% dilatedPx_comb <- dilatedPx + dilatedPx_mirrorx + dilatedPx_mirrory + dilatedPx_mirrorxy
%
% # we just want a binary labeling
% dilatedPx_comb[dilatedPx_comb > 0] <- 1
%
% # the dilated boundaries will have also grown into the blobs, so we take those
% # pixels out
% dilatedPx_comb[blobBoundaries[[1]][[2]] > 0] <- 0
%
% # from: https://stackoverflow.com/questions/34756755/plot-outline-around-raster-cells
% outline <- dilatedPx_comb %>%
%   as.data.frame() %>%
%   filter(value > 0) %>%
%   mutate(x = x-1,
%          y = y-1) %>%
%   raster::rasterFromXYZ() %>%
%   raster::rasterToPolygons(dissolve = TRUE) %>%
%   fortify() %>%
%   #the boundaries around the filtered blobs all share a common value in the
%   #"hole" column of TRUE
%   filter(hole) %>%
%   # remove padding used previously
%   mutate(lat = lat-5,
%          long = long-5)
% @
%
% <<nonMatchCCP_explore,eval=FALSE>>=
% patchComparisonPlts[[3]] +
%   cowplot::theme_nothing() +
%   labs(subtitle = "Filtered Element-wise Average\nAbs. Differences at Most 1") +
%   theme(plot.margin = margin(0,25,0,25),
%         plot.subtitle = element_text(hjust = .5,size = 8,vjust = -5)) -
%   geom_raster(fill = "gray80") +
%   geom_path(data = outline,
%             color = "grey40",
%             aes(x=long,y=lat,group=group,colour=group),
%             inherit.aes = FALSE,
%             size = .5) +
%   guides(fill = "none") +
%   theme(legend.position = "bottom")
% @
%
%
% <<nonMatchCCP_combine,eval=TRUE,cache=TRUE,include=FALSE>>=
% `-.gg` <- function(plot, layer) {
%   if (missing(layer)) {
%     stop("Cannot use `-.gg()` with a single argument. Did you accidentally put - on a new line?")
%   }
%   if (!is.ggplot(plot)) {
%     stop('Need a plot on the left side')
%   }
%   plot$layers = c(layer, plot$layers)
%   plot
% }
%
% topLeft <- patchComparisonPlts[[1]] +
%   cowplot::theme_nothing() +
%   labs(subtitle = "K013sA1 Cell 5, 1") +
%   theme(plot.margin = margin(0,0,5,0),
%         plot.subtitle = element_text(hjust = .5,size = 8,vjust = -1)) +
%   geom_raster(data = combinedValues %>%
%                 filter(is.na(refValue) & !is.na(targValue)),
%               fill = "gray40")
%
% bottomLeft <-patchComparisonPlts[[2]] +
%   cowplot::theme_nothing() +
%   labs(subtitle = "K002eG1 Aligned Cell\nat 3Â°") +
%   theme(plot.margin = margin(-20,-100,30,-100),
%         plot.subtitle = element_text(hjust = .5,vjust = -78,size = 8)) +
%   geom_raster(data = combinedValues %>%
%                 filter(!is.na(refValue) & is.na(targValue)),
%               fill = "gray40")
%
% middle <- patchComparisonPlts[[3]] +
%   cowplot::theme_nothing() +
%   labs(subtitle = paste0("Filtered Element-wise Average\nAbs. Differences at Most ",round(nonMatchCellPairThresh,2))) +
%   theme(plot.margin = margin(0,25,0,25),
%         plot.subtitle = element_text(hjust = .5,size = 8,vjust = -5)) -
%   geom_raster(fill = "gray80") +
%   geom_path(data = outline %>%
%               filter(!(group %in% c("1.22","1.23"))),
%             aes(x=long,y=lat,group=group), color = "grey40",
%             inherit.aes = FALSE,
%             size = .5)
%
% topRight <- patchComparisonPlts[[4]] +
%   cowplot::theme_nothing() +
%   labs(subtitle = paste0("Filtered K013sA1 Cell 5, 1\nAbs. Differences Greater Than ",round(nonMatchCellPairThresh,2))) +
%   theme(plot.margin = margin(0,0,5,0),
%         plot.subtitle = element_text(hjust = .5,size = 8)) -
%   geom_raster(fill = "gray80") +
%   geom_path(data = outline %>%
%               filter(!(group %in% c("1.22","1.23"))), color = "grey40",
%             aes(x=long,y=lat,group=group),
%             inherit.aes = FALSE,
%             size = .25)
%
% bottomRight <- patchComparisonPlts[[5]] +
%   cowplot::theme_nothing() +
%   labs(subtitle = paste0("Filtered K002eG1 Aligned Cell\nAbs. Differences Greater Than ",round(nonMatchCellPairThresh,2))) +
%   theme(plot.margin = margin(-20,-100,30,-100),
%         plot.subtitle = element_text(hjust = .5,vjust = -78,size = 8)) -
%   geom_raster(fill = "gray80") +
%   geom_path(data = outline %>%
%               filter(!(group %in% c("1.22","1.23"))), color = "grey40",
%             aes(x=long,y=lat,group=group),
%             inherit.aes = FALSE,
%             size = .25)
%
% design <- "ACCD
%            BCCE"
%
% patchComparisonPlts_nonMatch_combined <- patchwork::wrap_plots(topLeft,bottomLeft,middle,topRight,bottomRight,design = design) +
%   inset_element(patchComparisonLegend_nonMatch,left = -2.15,bottom = 0,right = -2.15,top = 0,on_top = FALSE,align_to = 'full')
%
% ggsave(plot = patchComparisonPlts_nonMatch_combined,
%        filename = "figures/complementCompPlot_nonMatch.png",
%        width = 7,height = 7,bg = "white")
% knitr::plot_crop("figures/complementCompPlot_nonMatch.png")
% @
%
% <<nonMatchCCP_show,out.width=".9\\textwidth",fig.cap="\\label{fig:fivePlotComparison_nonMatch} The complementary comparison plot for two cells from the comparison between cell 5, 1 of scan K013sA1 and its aligned cell in the non-match scan K002eG1. Compared to the aligned cells in the matching comparison shown in \\autoref{fig:fivePlotComparison}, we see that there are more dissimilarities between these two aligned cells. A black border is used to emphasize the filtered vs. non-filtered regions.", cache=FALSE>>=
% knitr::include_graphics("figures/complementCompPlot_nonMatch.png")
% @

\end{appendix}

\end{document}

